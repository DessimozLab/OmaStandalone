meth := 'BBH';
RefinedMatches := proc(
    ms:list( [posint,posint,numeric,numeric,posint..posint,posint..posint, positive]) )
    global BestMatch1, BestMatch2, g1, g2;
    t1+1;
    if g1=g2 then return() fi;

    for z in ms do
        if member(z[1],Exclude1) or member(z[2],Exclude2) or z[3] < MinScore
            then next fi;
        
        if not isContig[g1] and Lengths[g1,z[1]] < MinSeqLen then
            t7+1; next fi;
        if not isContig[g2] and Lengths[g2,z[2]] < MinSeqLen then
            t7+1; next fi;

        # if we need to enforce a length tolerance (we don't with contigs
        # this is the minimum length (avoids partial matches):
        maxl := max(Lengths[g1,z[1]],Lengths[g2,z[2]]);

        if meth='BBH' then score := round(100*z[3]);
        elif meth='RSD' then score := -round(1000*z[4]);
        else error('unknown method: '.meth.' (in utils/BBH.drw'); 
        fi:
 
        r5 := [op(z[5])];
        r6 := [op(z[6])];
        z[5]:= z[5,2]-z[5,1]+1;
        z[6]:= z[6,2]-z[6,1]+1;
        sumlengths := z[5]+z[6];
        if doLenC = true then
            if min(z[5],z[6]) < LengthTol*maxl then next fi;
        fi:
        
        if (BestMatch1[z[1]]=[] or BestMatch1[z[1],1,Score100] < score) and  
           (BestMatch2[z[2]]=[] or BestMatch2[z[2],1,Score100] < score) 
            then
            
          BestMatch1[z[1]] := [Pair(|score|,z[2],|score|,.1,sumlengths,r5,r6)];
          BestMatch2[z[2]] := [Pair(|score|,z[1],|score|,.1,sumlengths,r5,r6)];
        fi:
    od:
end:
