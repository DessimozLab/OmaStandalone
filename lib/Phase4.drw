Set(quiet):
#
#        Phase 4 of the Orthologous matrix
#        From the AllAll/*/* files produce the Orthologous Matrix
#        (for a fixed set of parameters)
#        Produces a file in Matrix/...
#                                        Gaston H. Gonnet (July 2004)
#                                        Gaston H. Gonnet (Sep 28, 2004)
#                                        Gaston H. Gonnet (Mar 31, 2005)
# echo "Class:=Cyanobacteria:  ReadProgram('Phase4.drw');" | darwindev
printf('# Matrix for %a started on %s\n# using %s, pid = %d\n',
	Class,date(),hostname(),getpid());
time_start := UTCTime():
Set(gc=5e7):  
SetRandSeed():  
if length(FileStat('UseHOMEdir'))>0 then 
     hdir := TimedCallSystem('echo $HOME')[2][1..-2]:
else hdir := '/home/darwin' fi:
if not assigned(synthetic_evolution) then
	wdir := hdir.'/v2/source/bio-recipes/Orthologues/':
	fdir := '/home/darwin/v2/source/bio-recipes/Orthologues/';
	ReadProgram( wdir . 'lib/darwinit' );
else
	#passed wdir, fdir and ldir
	ReadProgram( ldir.'omadarwinit' );
fi:
if not assigned(RemoveAltSplicing) then RemoveAltSplicing := true fi:
GS := GenomeSummaries:
VerifyClass;

###########################
# Setting main parameters #
###########################
ReadProgram( wdir . 'lib/Parameters' );

WriteOutFile := true:
#GetStats := true;
#ExcludePlasmids := true:
StrictLengthCrit := true;
#UseSeveralWitnesses := true;

##################################
# Set number of finished genomes #
##################################
do  g1 := genomes[-1];
    g2 := genomes[-2];
    if length(FileStat(fdir.'AllAll/'.g1.'/'.g2.'.gz')) > 0 or
       length(FileStat(fdir.'AllAll/'.g2.'/'.g1.'.gz')) > 0 then break fi;
    genomes := genomes[1..-2]
od:


N := length(genomes):
ns := CreateArray(1..N):
Lengths := CreateArray(1..N):
for i to N do
    if GS[genomes[i]]='unassigned' then
        lprint(genomes[i],'missing GenomeSummary information');  quit fi;
    t := GS[genomes[i],EntryLengths];
    ns[i] := length(t);
    Lengths[i] := t
od:

t1 := Counter('RefinedMatches structures read'):
t2 := Counter('Matches read'):
t3 := Counter('files read'):
t4 := Counter('Matches of genomes against themselves'):
t5 := Counter('Matches above parameters');
t6 := Counter('empty all-all'):
t7 := Counter('Number of matches discarded below MinSeqLen');

RefinedMatches := proc(
    ms:list( [posint,posint,numeric,numeric,posint..posint,
	posint..posint,positive]) )
    global BestMatch1, BestMatch2, g1, g2;
    t1+1;
    if g1=g2 then t4+length(ms) else t2+length(ms) fi;
    for z in ms do
        if member(z[1],Exclude1) or member(z[2],Exclude2) or z[3] < MinScore
            then next fi;
        minl := min(Lengths[g1,z[1]],Lengths[g2,z[2]]);
        if minl < MinSeqLen then t7+1; next fi;
	if StrictLengthCrit=true then # avoid matching of single domains
	    minl := max(Lengths[g1,z[1]],Lengths[g2,z[2]]) fi;
        sco100 := round(100*z[3]);
        dist10000 := round(10000*z[4]);
	var100000 := 100000*z[7];
        if var100000 > 1000 then var100000 := round(var100000) fi;
	z[5] := z[5,2]-z[5,1]+1;
	z[6] := z[6,2]-z[6,1]+1;
        sumlengths := z[5] + z[6];
        
        if g1=g2 then
            if z[1] >= z[2] then error(z,'invalid match')
            elif z[5] / minl >= LengthTol then BestMatch1[z[1]] :=
		append( BestMatch1[z[1]], Pair( sco100, z[2], dist10000, var100000,
						sumlengths )) fi
        else
            if z[5] / minl >= LengthTol then BestMatch1[z[1]] := 
                append(BestMatch1[z[1]],Pair(sco100,z[2],dist10000,var100000,
                                               sumlengths))
            fi;
            if z[6] / minl >= LengthTol then BestMatch2[z[2]] := 
                append(BestMatch2[z[2]],Pair(sco100,z[1],dist10000,var100000,
                                               sumlengths))
            fi;
        fi
    od:
end:

Set(quiet=false):
###########################################
# Read the BestMatch from all x all files #
###########################################
BestMatch := CreateArray(1..N,1..N):
for i to N do for j from i to N do
    BestMatch[i,j] := CreateArray(1..ns[i],[]);
    if j>i then BestMatch[j,i] := CreateArray(1..ns[j],[]) fi;
    if ns[i] < ns[j] or ns[i]=ns[j] and genomes[i] < genomes[j] then
        g1 := i;  g2 := j else g2 := i;  g1 := j fi;
        BestMatch1 := BestMatch[g1,g2];  BestMatch2 := BestMatch[g2,g1];
        fn := genomes[g1] . '/' . genomes[g2];
        t3+1;
        if ExcludePlasmids = true then
            Exclude1 := PlasmidEntries[genomes[g1]];
            Exclude2 := PlasmidEntries[genomes[g2]];
        else Exclude1 := Exclude2 := {} fi;
        ReadProgram( fdir . 'AllAll/' . fn );
        # no Pairs should be cut for being below the Scoretol, as those
        # may serve to break a stable pair
        sij := sum(length(BestMatch[i,j,k]), k=1..length(BestMatch[i,j]));
        sji := sum(length(BestMatch[j,i,k]), k=1..length(BestMatch[j,i]));
        t5+max(sij,sji);
        if sij=0 or sji=0 then
            t6+1;
	    # relax in case of mitochondion genome or synthetic evolution
            if not (genomes[g1,1] = 'm' or
		(assigned(synthetic_evolution) and g1=g2)) then
                error('empty all-all for', genomes[g1], genomes[g2] ) fi;
        fi;
	for k to length(BestMatch[i,j]) do
	    if BestMatch[i,j,k] <> [] then
		BestMatch[i,j,k] := compress(BestMatch[i,j,k]) fi od;
	for k to length(BestMatch[j,i]) do
	    if BestMatch[j,i,k] <> [] then
		BestMatch[j,i,k] := compress(BestMatch[j,i,k]) fi od;
        printf( '# %s done, (%d/%d)\n', fn, sij, sji );
od od:
print(t1,t2,t3,t4,t5,t6,t7);
# input example: [900,10602,292.2116998,36.92365265,101..201,83..243,128.7],
#                [entry1, entry2, sim, pam, range1,range2,variance]



#############################################################
# Code by Adrian S. to remove redundant splicing variants.  #
#############################################################
if RemoveAltSplicing then
ReadProgram('/home/darwin/DB/genomes/Splicings.drw'):
# find for each group of alternatively spliced genes
# the one with the most BestMatches.
S1 := Stat('matches of removed splice variants'):
S2 := Stat('matches of kept splice variants'):
remove := CreateArray(1..N,[]):
for i to N do
    if Splicings[genomes[i]]=0 then next fi;
    for alt in Splicings[genomes[i]] do
        NM := [seq(sum(length(decompress(BestMatch[i,j,k])),j=1..N),k=alt)];
        best := SearchArray(max(NM),NM);
        remove[i] := append(remove[i],op(alt minus {alt[best]}));
        for k to length(alt) do
            if k=best then S2+NM[k] else S1+NM[k] fi:
        od:
    od:
od:
print(S1,S2);
# remove all BestMatches involving a removed splicing variant
for i to N do remove[i] := {op(remove[i])} od:
for i to N do for j to N do
    nold := nnew := 0:
    for k to ns[i] do
        if BestMatch[i,j,k]=[] then next fi;
        tmp1 := decompress(BestMatch[i,j,k]);
        nold := nold+length(tmp1);
        if member(k,remove[i]) then BestMatch[i,j,k] := []; next fi;
        tmp2 := [seq(If(member(z['Entry'],remove[j]),NULL,z),
                                z=tmp1)];
        if tmp2=[] then BestMatch[i,j,k] := []
        else BestMatch[i,j,k] := compress(tmp2) fi;
        nnew := nnew+length(tmp2);
    od:
    printf('%s/%s: remove %d BestMatches, keep %d\n',
                        genomes[i],genomes[j],nold-nnew,nnew);
od od:
fi: # RemoveAltSplicing

cput_mid := time(); time_mid := UTCTime();
printlevel := 3:
NumberFormat := '%.8g':
params := [MinScore, LengthTol, StablePairTol, VerifiedPairTol]:
Ort := OrthologousMatrix( op(params) ):
if StrictLengthCrit=true then tit := tit.' (max Length) ' fi;
if RemoveAltSplicing=true then tit := tit.' (only 1 isoform used) ' fi;
if GetStats = true then ReadProgram('PrintStats.drw') fi;

if WriteOutFile = true then
    fn := TimedCallSystem( 'date "+Matrix/'.Class.'%b%d"')[2,1..-2];
    Set(quiet):
    OpenWriting( wdir . fn );
    printf( 'ProteinsInGroups := %d:\n', sum( histog[i]*i, i=1..N ));
    printf( 'params := %a:\n', params );
    printf( 'genomes := %a:\n', genomes );
    printf( 'genomefilenames := %A:\n',[seq(GenomeFileName[z,25..-1],z=genomes)]);
    printf( 'RemoveAltSplicing := %A:\n', RemoveAltSplicing );
    printf( 'histog := %a:\n', histog );
    printf( 'triangle_analysis := %A:\n', triangle_analysis );
    printf( 'stats := %A:\n', stats );
    printf( 'Class := %A:\n', Class );
    printf( 'ExcludePlasmids := %A:\n', ExcludePlasmids );
    printf( 'tit := ''%s, %s, %d species, %d orthologs'':\n', tit, 
           date(), length(genomes), length(Ort) );
    printf( 'Orthologous := _M := CreateArray(1..%d,1..%d):\n',length(Ort),length(Ort[1]));
    for i to length(Ort) do for j to length(Ort[1]) do
	if Ort[i,j]>0 then printf('_M[%d,%d]:=%d:\n',i,j,Ort[i,j]) fi;
    od od:
    printf( '# sizes: BestMatch %.0fMw, Orthologous %.0fMw, VPairs %.0fMw,' .
	' StablePairs %.0fMw\n', size(BestMatch)/1e6, size(Ort)/1e6,
	size(VPairs)/1e6, size(StablePairs)/1e6 );
    printf( '# time used: %.3f hrs on %s\n', time()/3600, hostname() );
    OpenWriting( previous );

    # we store the VPairs array for further analysis
    i := SearchString( 'Matrix/', fn ):
    if i < 0 then lprint('should not happen',i,fname);  fi:
    VPname := fn[1..i] . 'VPs/' . fn[i+8..-1]:
    OpenWriting(wdir.VPname):
    nsp := length(genomes):
    printf('VPairs := _V := CreateArray(1..%d, 1..%d):\n',nsp,nsp);
    for i to nsp do for j to nsp do
	if VPairs[i,j]=0 then next fi;
	printf('_V[%d,%d] := %A:\n',i,j,VPairs[i,j]);
    od od:
    printf('BrokenPairs := _B := CreateArray(1..%d, 1..%d):\n',nsp,nsp);
    for i to nsp do for j to nsp do
	if StablePairs[i,j]=0 then next fi;
	printf('_B[%d,%d] := _tmp := CreateArray(1..%d,{}):\n',i,j,
		length(StablePairs[i,j]));
	for k to  length(StablePairs[i,j]) do
	    t := decompress(StablePairs[i,j,k]) minus decompress(VPairs[i,j,k]);
	    if t={} then next fi;
	    printf('_tmp[%d]:=%A:\n',k,t);
	od:
    od od:
    #print('VPairs := '):  lprint(VPairs):  print(':'):
    OpenWriting(previous):
    CallSystem('gzip -f -9 '.wdir.VPname);
    
    quit
fi:

