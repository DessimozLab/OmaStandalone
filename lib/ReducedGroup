#
#	Given a class, find a small subset (of a given size, or
#	of a given minimum distance between its members)
#	which is obtained by removing the leaves that are
#	very close to each other.  The species chosen from
#	close pairs are those which have the highest number of
#	orthologous groups.
#
#	If both conditions are given (Size and MinDist), the list
#	returned is the largest of the two.
#
#	The output is a list of genomes.
#
#                                        Gaston H. Gonnet (Mar 13, 2008)
#

ReducedGroup := proc( prefix:string ;
	(Size=1):posint,
	'MinDist'=((MinDist=0):positive) )
global MatrixFileName, Orthologous, BestTreeDists, BestDimlessTree,
	BestTreeVars;

Orthologous := noeval(Orthologous);
BestTreeDists := noeval(BestTreeDists);
BestDimlessTree := noeval(BestDimlessTree);
BestTreeVars := noeval(BestTreeVars);

# select most recent file from the Matrix directory
wdir := '/home/darwin/v2/source/bio-recipes/Orthologues/':
fn := TimedCallSystem( 'ls -t ' . wdir . 'Matrix/' . prefix . '* | head -1' ):
if fn[1] <> 0 then lprint('cannot find file',fn);  quit fi;
if fn[2,-4..-2] = '.gz' then fname := fn[2,1..-5] else fname := fn[2,1..-2] fi:
printf( '# reading %s\n', fname );
ReadProgram( fname );
if length(genomes) <> length(Orthologous[1]) then
     lprint('non-matching lengths');  quit fi;
MatrixFileName := fname;

if not type(Orthologous,matrix(integer)) then
     error(fname,'Orthologous matrix not defined')
elif not type(BestDimlessTree,Tree) then
     error(fname,'BestDimlessTree tree not defined')
elif not type(BestTreeDists,matrix(nonnegative)) then
     error(fname,'BestTreeDists matrix not defined')
elif not type(BestTreeVars,matrix(nonnegative)) then
     error(fname,'BestTreeVars matrix not defined')
fi;

M := Orthologous:
N := length(M[1]):
lM := length(M):
ns := [seq(GS[i,TotEntries],i=genomes)]:
histog2 := CreateArray(1..N):
for i to lM do j := sum( If(z=0,0,1), z=M[i] );  histog2[j] := histog2[j]+1 od:
if histog <> histog2 then
    lprint(histog,histog2,histog2-histog,'inconsistent data');  quit fi;

map := [seq(i,i=1..N)]:
while length(map) > Size do
    n := length(map);

    # find the two closest species according to the distance matrix
    closest := [DBL_MAX];
    for i1 to n do for i2 from i1+1 to n do
	if closest[1] > BestTreeDists[map[i1],map[i2]] then
	    closest := [BestTreeDists[map[i1],map[i2]], i1, i2]
	fi
    od od;
    if closest[1] >= MinDist then break fi;
    m1 := map[closest[2]];  m2 := map[closest[3]];

    # find which species is most used in the Orthologous matrix
    u1 := u2 := 0;
    for z in M do
	if z[m1] > 0 then u1 := u1 + sum( If(z[i]>0,1,0), i=map ) fi;
	if z[m2] > 0 then u2 := u2 + sum( If(z[i]>0,1,0), i=map ) fi;
    od;
    excl := closest[ If( u1 > u2, 3, 2 ) ];
    printf( 'closest pair: %s/%d and %s/%d at %g, %s excluded\n',
	genomes[m1], u1, genomes[m2], u2, closest[1], genomes[map[excl]] );

    map := [op(1..excl-1,map), op(excl+1..n,map)];
od:

[seq(genomes[i],i=map)]
end:
