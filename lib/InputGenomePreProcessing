# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/2.0/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is OMA standalone.
#
# The Initial Developer of the Original Code is CBRG Research Group; 
# ETH Zurich; Switzerland.
# Portions created by the Initial Developer are Copyright (C) 2005-2013
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Christophe Dessimoz <cdessimoz@inf.ethz.ch>
#   Adrian Altenhoff <adrian.altenhoff@inf.ethz.ch>
#   Stefan Zoller <stefan.zoller@inf.ethz.ch>
#   Adrian Schneider <adrian.schneider@inf.ethz.ch>
#   Alexander Roth <alexander.roth@inf.ethz.ch>
#   Gaston Gonnet <gonnet@inf.ethz.ch>
#
# ***** END LICENSE BLOCK *****

CleanupSequences := proc(seqs_ids_tuple, gname, minLen)
    ids := seqs := []:
    for i to length(seqs_ids_tuple[1]) do
        s := uppercase(seqs_ids_tuple[1,i]):
        # minimal check of sequences
        if length(s) < minLen then
            warning( sprintf( 
                'Sequence %s (%s) is shorter (%d) than MinSeqLen=%d AA long. Ignored.\n',
                seqs_ids_tuple[2,i], gname, length(s), minLen));
            next;
        fi;
        c_toX := 0;
        for j to length(s) do
            aa := AToInt(s[j]);
            if aa < 1 or aa > 21 then
                warning(sprintf('Unknown character: %s (in %s, %s pos %d) --> X', 
                    s[j], seqs_ids_tuple[2,i], gname, j));
                s[j] := 'X';
                c_toX := c_toX+1;
            fi;
        od;
        if c_toX>=5 and c_toX>.05*length(s) then
            warning('Too many unknwon chars in %s, %s. skipping.',
                seqs_ids_tuple[2,i],gname);
            next;
        fi:
        seqs := append(seqs, s);
        ids := append(ids, CleanID(seqs_ids_tuple[2,i]));
    od:
    # check that IDs are uniq
    if length(ids) <> length({op(ids)}) then
        warning('not all IDs are uniq. This may cause problems with interpreting the results');
    fi:
    return([seqs, ids]);
end:

CleanID := proc(id)
    tmpID := ReplaceString('\t','', id);
    tmpID := ReplaceString('<','',tmpID);
    tmpID := ReplaceString('>','',tmpID);
    return(tmpID);
end:
    
