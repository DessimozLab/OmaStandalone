#
#	Phase 1 of the Orthologous matrix
#	Compute the all x all of two genomes (in parallel)
#					Gaston H. Gonnet (July 2004)
if not type(i1s,list(posint)) then
    lprint(i1s,'is not a list(posint)');  quit fi;
typ := 'SEQ':
ReadProgram( 'bio-recipes/Orthologues/Phase0.drw' );
printf( '# %s vs %s on %s, pid %5d, %s, i1s=%a\n', name1, name2, hostname(),
	getpid(), date(), i1s );
lprint( 'RefinedMatches(' );
t0 := UTCTime():

##########################
#  all x all alignments  #
##########################
res := []:
for i1 in i1s do
    len1 := length(Seqs1[i1]);
    for i2 from If( name1=name2, i1+1, 1 ) to n2 do
	len2 := length(Seqs2[i2]);
	dps := DynProgScore(Seqs1[i1],Seqs2[i2],DM,JustScore);
	if dps[1] >= 85 then
	     a := Align(Seqs1[i1],Seqs2[i2],DMS);
	     if a[Score] < 130 or min(a[Length1],a[Length2]) <
			max(30,0.3*min(len1,len2)) then next fi;
	     i := GetOffset(a[Seq1])-GetOffset(Seqs1[i1]);
	     ran1 := i+1 .. i+a[Length1];
	     i := GetOffset(a[Seq2])-GetOffset(Seqs2[i2]);
	     ran2 := i+1 .. i+a[Length2];
	     res := append(res,[i1,i2,a[Score],a[PamDistance],
			ran1,ran2,a[PamVariance]] );
	     fi;
	od;
    od:
NumberFormat := '%.10g':
if res = [] then lprint( res, '):' )
else printf( '[' );
     for i to length(res)-1 do printf('%a,\n',res[i]) od:
     lprint( res[-1], ']):' )
fi:

drt := UTCTime()-t0:
dat := time():
printf('# %s: %ds/%ds active = %.1f%%  %s\n',hostname(),round(dat),round(drt),
	100*dat/drt,If(dat/drt<0.7,'SLOW!',''));

    HashSeqs:
    h1 := hashstring(db1[string]):
    if h1 <> HashGenome[name1] then lprint( 'signature failed', h1 );  done fi:
    h2 := hashstring(db2[string]):
    if h2 <> HashGenome[name2] then lprint( 'signature failed', h2 );  done fi:
    printf( '# Checksums: h1=%.0f, h2=%.0f\n', h1, h2 );

printf( '# %s: %.3f hrs, %.2f mega-cell/sec\n', hostname(), time()/3600,
    Set(TotalDPCells) * 1e-6 / time() );
done;


Set(quiet):
commfile := '/home/darwin/v2/source/comm/xxx1':
tottime := totcomm := 0:
typ := 'SEQ':
ReadProgram( '/home/darwin/v2/source/bio-recipes/Orthologues/lib/darwinit' );
GS := GenomeSummaries:
name2 := ERWCT;
for name2 in [JANSC,GEOMG,NEOSM,ANAVT,BORA1,THIDA] do


for name1 in genomes do
    if GS[name1,TotEntries] > GS[name2,TotEntries] or
       GS[name1,TotEntries] = GS[name2,TotEntries] and name1 > name2 then
	 nam1 := name2;  nam2 := name1
    else nam1 := name1;  nam2 := name2 fi;
    n1 := GS[nam1,TotEntries];  n2 := GS[nam2,TotEntries];
    lens1 := GS[nam1,EntryLengths]:  lens2 := GS[nam2,EntryLengths]:

    ########################################
    # generate commands to run in parallel #
    ########################################
    i1s := sort( [seq(i,i=1..n1)], x -> -lens1[x] ):
    totlen2 := GS[nam2,TotAA]:
    slow := slowest / totpow;
    t := totlen2 * GS[nam1,TotAA] / cellsec / 3600;
    # do not run less than 2 hours on the slowest machine
    minlen := 2*3600*slowest*cellsec/totlen2;
    printf( '%s vs %s: %.1f hours/Ghz total time, (%.2f hrs in cluster)\n',
	nam1, nam2, t, t/totpow );
    tottime := tottime + t/totpow;

    OpenAppending( commfile );
    lprint( '#!/bin/csh' );
    lprint( 'set noclobber' );
    lprint( 'unlimit stacksize' );
    lprint( 'cd /home/darwin/v2/source' );
    for i1 to n1 do

        # Run for the remaining time in the worst case
        totlen1 := max( minlen, sum(lens1[i1s[j]],j=i1..n1) * slow * 0.8 ) -
	    lens1[i1s[i1]];
    
        for i2 from i1 to min(n1-1,i1+498) while totlen1 > lens1[i1s[i2+1]] do
	    totlen1 := totlen1 - lens1[i1s[i2+1]] od;
        printf( '( echo "name1:=%s: name2:=%s: typ:=%s: i1s:=[%d', nam1, nam2,
	    typ, i1s[i1] );
        for j from i1+1 to i2 do printf( ',%d', i1s[j] ) od;
        printf( ']:" ; cat bio-recipes/Orthologues/Phase1.drw ) |' );
        printf( ' darwin -q >bio-recipes/Orthologues/tmp%s-%s%d-%d\n',
	    nam1, nam2, i1, i2 );
        i1 := i2;
	totcomm := totcomm+1;
        od:
    OpenWriting( previous );
    CallSystem( 'chmod +x ' . commfile );
    if name2=name1 then break fi;
od:
printf( '%.2f hours, %d commands for the entire %s\n',
    tottime, totcomm, name2 );
done


setenv N +19
foreach i ( \
           23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \
           23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \
        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20    \
        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 )
    rsh linneus$i "nice $N v2/source/comm/xxx1" </dev/null & ; sleep 9
end
foreach i ( 43 43 43 43 44 44 45 46 47 \
	48 48 48 48 48 48 48 48 48 48 48 48 48 \
	49 49 49 49 49 49 49 49 49 49 49 49 49 \
	50 52 52 54 54 54 54 55 55 55 55 \
	51 51 51 51 51 51 51 51 51 51 51 51 51 51 \
	51 51 51 51 51 51 51 51 51 51 51 51 51 51 \
	53 53 53 53 53 53 53 53 53 53 53 53 53 53 \
	53 53 53 53 53 53 53 53 53 53 \
	56 56 56 56 56 56 56 56 56 56 56 56 56 56 56 56 \
	56 56 56 56 56 56 56 56 56 56 56 56 56 56 56 56 \
	57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 \
	57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 \
)
   ssh linneus$i.inf.ethz.ch "nice $N v2/source/comm/xxx1" </dev/null & ; sleep 9
end
foreach i ( 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
	81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 \
	65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \
	81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 )
   ssh xibalba1$i.inf.ethz.ch "nice $N v2/source/comm/xxx1" </dev/null& ; sleep 9
end
# machines that need to start the shells in the machine
foreach i ( lumberjack sim0 sim64 linneus53 )
   echo sshing into $i
   ssh $i.inf.ethz.ch
end
nice +19 csh <v2/source/comm/xxx1 &


foreach i ( saturn saturn saturn saturn saturn saturn saturn saturn \
        phobos phobos deimos deimos )
  ssh $i "nice +19 darwin/v2/source/comm/xxx1.saturn" </dev/null & ; sleep 15
  end

