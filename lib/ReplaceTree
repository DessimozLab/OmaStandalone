#
#	ReplaceTree( Skeleton:Tree, Insert:Tree )
#	or
#	ReplaceTree( Skeleton:SpeciesClass, Insert:SpeciesClass )
#
#	Replace a given tree into a Skeleton tree, return a
#	complete tree.  This function is designed to fill in
#	a skeleton of a tree with more detailed subtrees which
#	replace part of the skeleton.
#
#	E.g.
#	   Skeleton = Tree( subtree1, 0, Tree( subtree2, 1, subtree3 )
#	   Insert = Tree(...)
#	   assume also that Leaves(subtree2) minus Leaves(Insert) = {}
#
#	   then the result is Tree( subtree1, 0, Tree( Insert, 1.3, subtree3)
#	   with all the depths properly adjusted
#
#	The distances in both trees may be in different scales (even
#	if they are in PAM, as a different subset of proteins may have
#	been averaged).  This function estimates the two rates based
#	on the leaves in common and adjusts the Insert tree accordingly.
#	The rate is printed and stored in the global variable
#	Ratio_Insert_Skeleton.
#
#					Gaston H. Gonnet (15.03.2008)
#
#
ReplaceTree := proc( Skeleton:{Tree,SpeciesClass}, Insert:{Tree,SpeciesClass} )
global Ratio_Insert_Skeleton;
if type(Skeleton,SpeciesClass) and type(Insert,SpeciesClass) then
    return( ReplaceTree_SpeciesClass( args ) ) fi;

CleanTree := proc( t:Tree )
if type(t,Leaf) then
     g := t[1];
     if type(g,Color(string,string)) then g := g[2] fi;
     Leaf(g,t[2])
else Tree( procname(t[1]), t[2], procname(t[3])) fi
end:

leaves := proc( t:Tree )
if type(t,Leaf) then {t[1]}
else remember(procname(t[1])) union (procname(t[3])) fi
end:

ske := CleanTree( Skeleton );
ins := CleanTree( Insert );

ske_leaves := leaves(ske);
ins_leaves := leaves(ins);
comm := ske_leaves intersect ins_leaves;
lcomm := length(comm);
if lcomm <= 1 then error(
    'not enough leaves in the intersection, does not know where to insert')
elif leaves(ske) minus leaves(ins) = {} then
     return(ins)
fi;

# return A (all in comm), M (mixed) or 0 (none in comm)
S := proc( t:Tree )
r := remember(leaves(t));
assert( r <> {} );
if r minus comm = {} then 'A'
elif r intersect comm = {} then 0
else 'M' fi end:

# rotate ske until all the leaves in comm are on the left
do
    if S(ske[1]) = 0 or S(ske[3]) = 'A' then
	 ske := Tree(ske[3],ske[2],ske[1]);  next
    elif S(ske[1]) = 'M' and S(ske[3]) = 'M' then
	 error('Skeleton tree does not have contiguous leaves in common')
    elif S(ske[1]) = 'A' then
	 if S(ske[3]) = 0 then break
	 else assert( not type(ske[3],Leaf) );
	      if member( S(ske[3,3]), {0,'M'}) and S(ske[3,1]) = 'A' then
		   ske := RotateTree(ske,Right,Right);  next
	      elif member( S(ske[3,1]), {0,'M'}) and S(ske[3,3]) = 'A' then
		   ske := RotateTree(ske,Right,Left);  next
	      else error('Skeleton tree does not have contiguous leaves in common')
	      fi
	 fi
    elif S(ske[3]) = 0 then
	 assert( not type(ske[1],Leaf) );
	 if S(ske[1,1]) = 0 then ske := RotateTree(ske,Left,Right);  next
	 elif S(ske[1,3]) = 0 then ske := RotateTree(ske,Left,Left);  next
	 else error('Skeleton tree does not have contiguous leaves in common')
	 fi
    elif S(ske[1]) = 'A' then
	 assert( not type(ske[3],Leaf) );
	 if S(ske[3,1]) = 'A' then ske := RotateTree(ske,Right,Right);  next
	 elif S(ske[3,3]) = 'A' then ske := RotateTree(ske,Right,Left);  next
	 else error('Skeleton tree does not have contiguous leaves in common')
	 fi
    else error(incomplete2)
    fi
od;
	 


# compute the distances all x all distances matrix for comm
# in the Skeleton and in Insert.  From this extract the factor
# that converts distances from Skeleton to Insert.  I.e.
# d(Skeleton) * f = d(Insert)

########################################################################
# convert a Tree into a distance matrix, based on a set/list of leaves #
########################################################################
Tree_matrix_list := proc( t:Tree, leavs:{set,list} )

leavs0 := If( type(leavs,list), leavs, [op(leavs)] );
ls := [];
for z in Leaves(t) do
    i := SearchArray(z[1],leavs0);
    if i > 0 then ls := append(ls,[i,z[Height]]) fi
od;

n := length(ls);
assert( {seq(z[1],z=ls)} = {seq(i,i=1..n)} );
D := CreateArray(1..n,1..n);
if n<2 then return(D) fi;
hei := CreateArray(1..n):
for z in ls do hei[z[1]] := z[2] od:

ComputeDist := proc( t1:Tree )
global D;
if type(t1,Leaf) then
     i := SearchArray(t1[1],leavs0);
     if i > 0 then {i} else {} fi
else l1 := procname( t1[1] );
     l3 := procname( t1[3] );
     t1h := t1[Height];
     for i1 in l1 do for i3 in l3 do
        D[i1,i3] := D[i3,i1] := |t1h-hei[i1]| + |t1h-hei[i3]| od od;
     l1 union l3
fi
end:

ComputeDist( t );
D
end:


Ske_common := Tree_matrix_list( ske[1], comm );
Ins_common := Tree_matrix_list( ins, comm );
sum_Ske := sum(sum(Ske_common));
if sum_Ske = 0 then error('not enough nodes in common to match distances') fi;
Ratio_Insert_Skeleton := f := sum(sum(Ins_common)) / sum_Ske;
if f < 0.3 or f > 3 then error(f,'unreasonable Ratio_Insert_Skeleton') fi;
printf( 'conversion factor: d(Insert)/d(Skeleton) = %g\n', f );

##################################################
# Adjust distances in ins tree (no need to copy) #
##################################################
proc( t:Tree ) t[Height] := t[Height]/f;
if not type(t,Leaf) then procname(t[1]); procname(t[3]) fi end( ins );


#####################################################
# now compute the distances from the root of ske[3] #
# to the leaves (based on Skeleton)                 #
#####################################################
Dist_to_comm := CreateArray(1..lcomm);
for z in Leaves(ske[1]) do
    for i to lcomm while comm[i] <> z[1] do od;
    Dist_to_comm[i] := z[Height]
od;
for i to lcomm do
    Dist_to_comm[i] := |ske[2]-Dist_to_comm[i]| + |ske[2]-ske[3,2]|
od;


##################################################################
# compute the error of approximating the distances at the        #
# given root (plus a stem, plus an optimal location of the root) #
##################################################################
#
#         |
#        c|
#         o
#       a/ \b   (a+b=g)
#       /   \
#      /\   /\
#     /l \ /r \
#
#  The maple code to compute the branch lengths and error are:
# a+b = g;
# a := g-b;
# S2 := sum((l[i]+a+c-d[i])^2,i=1..nl) + sum((r[j]+c+b-d[j])^2,j=1..nr);
# eqns := {diff(S2,b),diff(S2,c)};
# sol := solve(eqns,{b,c});
# spat := { sum(l[i],i=1..nl)=sumli, sum(d[i],i=1..nl)=sumdi,
#     sum(r[j],j=1..nr)=sumrj, sum(d[j],j=1..nr)=sumdj };
# sol := subs( spat, sol );
# expand( subs(sol,b) );
# expand( subs(sol,c) );
# err := expand( subs(sol,S2) );
# for z in indets(err,function) do
#     if op(0,z)=sum and type(op(1,z),`+`) then
# 	err := subs( z=map(sum,op(1,z),op(2,z)), err ) fi
# od;
# err := subs( spat, expand(err));

Err_root := proc( t:Tree )
dist_leaves := CreateArray( 1..lcomm );
for z in Leaves(t) do
    for i to lcomm while comm[i] <> z[1] do od;
    if i <= lcomm then dist_leaves[i] := z[Height] fi
od;
ll := leaves(t[1]);
sumdi := sumdj := sumli := sumrj := err := nl := nr := 0;
for i to lcomm do
    if member(comm[i],ll) then
	 nl := nl+1;
	 sumdi := sumdi + Dist_to_comm[i];
	 li := |t[1,2]-dist_leaves[i]|;
	 sumli := sumli + li;
    else
	 nr := nr+1;
	 sumdj := Dist_to_comm[i];
	 rj := |t[3,2]-dist_leaves[i]|;
	 sumrj := sumrj + rj;
    fi
od;
assert( nl+nr = lcomm and nl = length(ll intersect comm) );
g := |t[2]-t[1,2]| + |t[2]-t[3,2]|;
b := ( g + If( nr>0, (sumdj-sumrj)/nr, 0 ) +
	   If( nl>0, (sumli-sumdi)/nl, 0 ) ) / 2;
if b < 1e-6 then b := 1e-6
elif b > g-1e-6 then b := g - 1e-6 fi;
a := g - b;
c := ( If( nr>0, (sumdj-sumrj)/nr, 0 ) - g +
	If( nl>0, (sumdi-sumli)/nl, 0 ) ) / 2;
if c < 1e-6 then c := 1e-6 fi;
for i to lcomm do
    if member(comm[i],ll) then
	 li := |t[1,2]-dist_leaves[i]|;
	 err := err + (Dist_to_comm[i]-(li+a+c))^2;
    else
	 rj := |t[3,2]-dist_leaves[i]|;
	 err := err + (Dist_to_comm[i]-(rj+b+c))^2
    fi
od;
[err,a,b,c,t]
end:


#######################################################
# Loop to find the best branch to attach the ins tree #
#######################################################
improv := true;
best := Err_root(ins);
while improv do
    improv := false;
    ins := best[5];
    if not type(ins[1],Leaf) then
	t1 := RotateTree(ins,Left,Left);
	t2 := Err_root(t1);
	lprint( Left, Left, t2[1] );
	if t2[1] < best[1] then best := t2;  improv := true fi;
	if not type(t1[1],Leaf) then
	     t11 := RotateTree(t1,Left,Left);
	     t2 := Err_root(t11);
	     lprint( Left, Left, Left, Left, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	     t11 := RotateTree(t1,Left,Right);
	     t2 := Err_root(t11);
	     lprint( Left, Left, Left, Right, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	fi;
	t1 := RotateTree(ins,Left,Right);
	t2 := Err_root(t1);
	lprint( Left, Right, t2[1] );
	if t2[1] < best[1] then best := t2;  improv := true fi;
	if not type(t1[1],Leaf) then
	     t11 := RotateTree(t1,Left,Left);
	     t2 := Err_root(t11);
	     lprint( Left, Right, Left, Left, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	     t11 := RotateTree(t1,Left,Right);
	     t2 := Err_root(t11);
	     lprint( Left, Right, Left, Right, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	fi;
    fi;
    if not type(ins[3],Leaf) then
	t1 := RotateTree(ins,Right,Left);
	t2 := Err_root(t1);
	lprint( Right, Left, t2[1] );
	if t2[1] < best[1] then best := t2;  improv := true fi;
	if not type(t1[3],Leaf) then
	     t11 := RotateTree(t1,Right,Left);
	     t2 := Err_root(t11);
	     lprint( Right, Left, Right, Left, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	     t11 := RotateTree(t1,Right,Right);
	     t2 := Err_root(t11);
	     lprint( Right, Left, Right, Right, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	fi;
	t1 := RotateTree(ins,Right,Right);
	t2 := Err_root(t1);
	lprint( Right, Right, t2[1] );
	if t2[1] < best[1] then best := t2;  improv := true fi;
	if not type(t1[3],Leaf) then
	     t11 := RotateTree(t1,Right,Left);
	     t2 := Err_root(t11);
	     lprint( Right, Right, Right, Left, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	     t11 := RotateTree(t1,Right,Right);
	     t2 := Err_root(t11);
	     lprint( Right, Right, Right, Right, t2[1] );
	     if t2[1] < best[1] then best := t2;  improv := true fi;
	fi;
    fi;
od;
printf( 'final cost of the best insertion place: %g\n', best[1] );


###########################
# Assemble the final tree #
###########################
sgn := sign( ske[Height]-ske[1,Height] );
add_height := proc( t:Tree, d:numeric )
if type(t,Leaf) then t[Height] := t[Height]+d
else t[Height] := t[Height]+d;  procname(t[1],d);  procname(t[3],d) fi;
t end;
r := Tree( Tree( add_height( ins[1], -ins[1,Height]-sgn*(best[4]/2+best[2])),
	-sgn*best[4]/2,
      	add_height( ins[3], -ins[3,Height]-sgn*(best[4]/2+best[3])) ), 0,
     add_height( ske[3], -sgn*best[4]/2 - ske[3,Height] ));
assert( ||r[2]-r[1,2]| + |r[2]-r[3,2]| - best[4]| < 1e-14 and
	||r[1,2]-r[1,1,2]| - best[2]| < 1e-14 and
	||r[1,2]-r[1,3,2]| - best[3]| < 1e-14 );
r
end:


ReplaceTree_SpeciesClass := proc( Skeleton:SpeciesClass, Insert:SpeciesClass )
global Ratio_Insert_Skeleton;

# find the new list of genomes
newgen := [op( {op(Skeleton[Genomes]),op(Insert[Genomes])} minus
	ExcludeFromAll)];
n := length(newgen);
nDist := CreateArray(1..n,1..n):
nVar := CreateArray(1..n,1..n):

mapSke := [seq( SearchArray(g,Skeleton[Genomes]), g=newgen )];
mapIns := [seq( SearchArray(g,Insert[Genomes]), g=newgen )];

# find the ratio between the distances
totSke := totIns := totcomm := 0;
DSke := Skeleton[Dist]:
VSke := Skeleton[Var]:
DIns := Insert[Dist]:
VIns := Insert[Var]:
for i to n do
    if mapSke[i] = 0 or mapIns[i] = 0 then next fi;
    for j from i+1 to n do
	if mapSke[j] = 0 or mapIns[j] = 0 then next fi;
	dSke := DSke[mapSke[i],mapSke[j]];
	dIns := DIns[mapIns[i],mapIns[j]];
	if dSke > 0 and dIns > 0 then
	    totSke := totSke+dSke;
	    totIns := totIns+dIns;
	    totcomm := totcomm+1
	fi
od od;
if totIns = 0 then error('not enough overlapping data') fi;
Ratio_Insert_Skeleton := f := totIns/totSke;
if f < 0.3 or f > 3 then error(f,'unreasonable Ratio_Insert_Skeleton') fi;
printf( 'conversion factor (%d in common): d(Insert)/d(Skeleton) = %g\n',
	totcomm, f );


# Fill the new matrix
varSke := varIns := iboth := 0;
for i to n do for j from i+1 to n do
    if mapSke[i] > 0 and mapSke[j] > 0 and not
	( DSke[mapSke[i],mapSke[j]] = 100 and
	  VSke[mapSke[i],mapSke[j]] = 1e10 ) then
	nDist[i,j] := nDist[j,i] := DSke[mapSke[i],mapSke[j]];
	nVar[i,j] := nVar[j,i] := VSke[mapSke[i],mapSke[j]];
    fi;
    if mapIns[i] > 0 and mapIns[j] > 0 and not 
	( DIns[mapIns[i],mapIns[j]] = 100 and
	  VIns[mapIns[i],mapIns[j]] = 1e10 ) then
	dIns := DIns[mapIns[i],mapIns[j]];
	if dIns > 0 then
	    nDist[i,j] := nDist[j,i] := dIns/f;
	    iVar := VIns[mapIns[i],mapIns[j]]/f^2;
	    if nVar[i,j] > 0 then
		varSke := varSke + nVar[i,j];
		varIns := varIns + iVar;
		iboth := iboth+1
	    fi;
	    nVar[i,j] := nVar[j,i] := iVar;
	fi
    fi;
od od;
printf( 'var(Ins)/var(Ske) = %g over %d points\n', varIns/varSke, iboth );

SpeciesClass( newgen, 0, nDist, nVar, Insert[FileName] );
end:
