module external WriteResults;

#####################################################################
#
# First some helper functions... bear with me for a moment.
#


# get nr of second contigs in arr w/o start codon,
# nr of contigs w/o start codon in whole DB,
# % of second contigs in arr w/o start codon,
# % of contig w/o start codon in whole DB
checkStartCodon := proc(setname:string, arr)
    global DB;
    
    #if setname = 'FAKH2' or setname = 'FAKEH' or setname = 'MOUSE34' then
    #    DB := ReadDb('Cache/DB/'.setname.'.db');
    #elif setname = 'Cmilii' then
    #    DB := ReadDb('Cache/DB/CmiliiFull.db');
    #else
    #    printf('DB not recognized in checkStartCodon().\n'):
    #    return(-1):
    #fi:

    DB := ReadDb('Cache/DB/' . setname . '.db'):

    missSec := 0;
    bgMiss := 0:
    for i in arr do
        secondContig := i[i[3,1,5,2],2]:
        if Sequence(Entry(secondContig))[1] <> 'M' then 
            missSec := missSec + 1;
        fi:
    od:
    for z in Entries() do
        if Sequence(z)[1] <> 'M' then bgMiss := bgMiss + 1: fi:
    od:
    missSecPerc := If(length(Arr)>0, 100*missSec/length(arr), 0):
    bgMissPerc := 100*bgMiss/DB['TotEntries']:
    return([missSec, missSecPerc, bgMiss, bgMissPerc]);
end:

# Parses array of contig hits and produces
# new array with, foreach element:
# [seqs, labels, stdfacs, species, gaps, corder, s3set]
ParseContigHits := proc(setname:string, arr;
        'allarr'=((allarr=true):boolean))
    global DB;
    hits := []: 
    # first, get labels and seq-data of found hits
    limitcount := 0;
    for i to length(arr) do
        isPositive := false:
        if length(arr[i]) > 4 and arr[i,5] = 'isPositive' then
                isPositive := true:
        fi:
        if not allarr and limitcount > 50 and (not isPositive or setname='MOUSE34') then next fi:
        seqs := []:
        labels := []:
        stdfacs := []:
        gaps := [];
        species := []:
        corder := []:

        #if setname = 'FAKH2' or setname = 'FAKEH' or 
        #    setname = 'MOUSE34' then
        #        DB := ReadDb('Cache/DB/'.setname.'.db');
        #elif setname = 'Cmilii' then
        #    DB := ReadDb('Cache/DB/CmiliiFull.db');
        #else
        #    printf('DB not recognized in ParseContigHits().\n'):
        #    return(-1):
        #fi:
        DB := ReadDb('Cache/DB/'.setname.'.db'):


        if arr[i,3,1,5] = [1,2] then
            first := 1;
            second := 2;
        else
            first := 2;
            second := 1;
        fi:
        
        seqs :=  append(seqs, string(SearchTag('SEQ', Entry(arr[i,first,2])))):
        labels := append(labels, string(SearchTag('ID', Entry(arr[i,first,2])))):

        seqs :=  append(seqs, string(SearchTag('SEQ', Entry(arr[i,second,2])))):
        labels := append(labels, string(SearchTag('ID', Entry(arr[i,second,2])))):

        for j to length(arr[i,3]) do
            DB := DBs[arr[i,3,j,1]];
            seqs :=  append(seqs, string(SearchTag('SEQ', Entry(arr[i,3,j,2])))):
            labels := append(labels, string(SearchTag('ID', Entry(arr[i,3,j,2])))):
            stdfacs := append(stdfacs, string(arr[i,3,j,3]));
            gaps := append(gaps, string(arr[i,3,j,4]));
            species := append(species, genomes[arr[i,3,j,1]]);
            corder := append(corder, arr[i,3,j,5]);
        od:
        s3set := []:
        for e in arr[i,4] do
            DB := DBs[arr[1,1,1]];
            s3set := append(s3set, SearchDelim(';', SearchTag('ID', Entry(e)))[1]);
        od:
        if not isPositive or setname='MOUSE34' then limitcount := limitcount + 1 fi:
        hits := append(hits, [seqs, labels, stdfacs, species, gaps, corder, s3set, isPositive]):
    od:

    # do some polishing on the labels    
    len := length(hits):
    for i to len do
        for j to length(hits[i,2]) do
            t := SearchDelim(';', hits[i,2,j]):
            hits[i,2,j] := t[1]:
        od:
    od:
    return(hits);
end:

####################################################
# 
# Writes parameters and metainformation to files in
# folder 'foldername'; additionally, also writes all
# seqs in fasta format in a tarball.
#
WriteResults := proc(foldername;
    'fasta'=((fasta=true):boolean),
    'contigset'=((contigset=''):string),
    'writeallmsas'=((writeallmsas=true):boolean))

    global DB, PossContigHits, DefContigHits:

    outFolder := '';

    outFolder := 'ContigOutput/'.foldername.'/';

    print(length(FileStat(outFolder)));
    if length(FileStat(outFolder)) = 0 then
        TimedCallSystem('mkdir -p '.outFolder);
    fi:

    if contigset <> '' then
        setname := contigset:
        DB := ReadDb('Cache/DB/'.contigset.'.db');
    else
        error(' needs name of contig set as parameter.');
    fi:

    printf('Write results: params.txt\n');
    OpenWriting(outFolder.'params.txt'):
        printf('MinSeqLenContig := %a;\nMinProbContig := %a;\nMaxContigOverlap := %a;\nMinBestScore := %a;\nDistConfLevel := %a;\nAllowMultipleHits := %a;\nDatasets := %a;\nContigStablePairTol := %a;\nStablePairTol := %a;\n\n',
                MinSeqLenContig, MinProbContig,
                MaxContigOverlap, MinBestScore, DistConfLevel, 
                AllowMultipleHits, G, ContigStablePairTol, StablePairTol);
        
    # total amount of hits, number of inconclusive hits
    totalHits := length(ContigHits):
    inconclusive := length(PossContigHits):
    if totalHits = 0 then
        if inconclusive > 0 then inconPerc := 100
        else inconPerc := 0:
        fi:
    else
        inconPerc := 100*inconclusive/totalHits:
    fi:
    printf('%a hits in total; %a (%2.2f%%) are not conclusive.\n\n',
            totalHits, inconclusive, inconPerc);
    
    # % of second contig w/o start codon
    startCodonArr := checkStartCodon(setname, DefContigHits):
    printf('Nr of second contigs w/o start codon: %a (%2.2f%%)\n',
            startCodonArr[1], startCodonArr[2]):
    printf('Nr of entries w/o start codon in whole genome: %a (%2.2f%%)\n',
            startCodonArr[3], startCodonArr[4]):

    OpenWriting(previous):
    
    # method to write proper file format
    WriteResultFile := proc(filename, hits, fastafolder, writeall)
        OpenWriting(filename);
        printf('# contigs are ordered according to their position relative to the putative ortholog\n');
        printf('# see for fasta files in folder "fasta/%a"\n', fastafolder):
        printf('## fragment-pair\tfirst fragment\tsecond fragment\tcorresponding full gene\tspecies\tdistance difference between fragments\t# positions between fragments\ts3 IDs\n');
        if writeall then
            limit := length(hits):
        else
            limit := min(length(hits), 500):
        fi:
        limitcount := 0;
        for k to length(hits) do
            if not writeall and limitcount = 50 and (not i[8] or setname='MOUSE34') then next fi:
            i := hits[k];
            for j to (length(i[2])-2) do
                printf('%a\t%a\t%a\t%a\t%a\t%a\t%a\t%a',
                    k, i[2,1], i[2,2], i[2,2+j], i[4,j], i[3,j], i[5,j], i[7]);
                printf('\n');
            od:
            if not i[8] or setname='MOUSE34' then limitcount := limitcount + 1 fi:
        od:
        OpenWriting(previous);
    end:
    
    # method to write a simple results file of hits
    WriteSimpleResultFile := proc(filename)
        global DB:
        OpenWriting(filename);
        printf('# contigs are ordered according to their position relative to the putative ortholog\n');
        printf('#first fragment\tsecond fragment\tlist of reference genes separated with semi-colons\n');
        for z in DefContigHits do
            DB := DBs[z[1,1]]; 
            id1arr := SearchDelim('|', SearchTag('ID', Entry(z[1,2]))):
            id1 := id1arr[2] . '|' . id1arr[3]:
            id1 := SearchDelim(';', id1)[1]:

            id2arr := SearchDelim('|', SearchTag('ID', Entry(z[2,2]))):
            id2 := id2arr[2] . '|' . id2arr[3]:
            id2 := SearchDelim(';', id2)[1]:

            if z[3,1,-1,1] = 2 then
                t := id1;
                id1 := id2;
                id2 := t;
            fi;

            printf('%a\t', id1):
            printf('%a\t', id2):

            if length(z[3]) > 1 then
                for i from 1 to length(z[3])-1 do
                    DB := DBs[z[3,i,1]]:
                    id := SearchDelim('|', SearchTag('ID', Entry(z[3,i,2])))[-1]:
                    id := SearchDelim(';', id)[1]:
                    printf('%a:%a; ', genomes[z[3,i,1]], id);
                od:
            fi:
            DB := DBs[z[3,length(z[3]),1]]:
            id := SearchDelim('|', SearchTag('ID', Entry(z[3,length(z[3]),2])))[-1]:
            id := SearchDelim(';', id)[1]:
            printf('%a:%a\n', genomes[z[3,length(z[3]),1]], id):
        od:
        OpenWriting(previous);
    end:
    
    printf('Write results: hits.txt\n');
    defHits := ParseContigHits(setname, DefContigHits):
    WriteResultFile(outFolder.'hits.txt', defHits, 'defhits', true);

    printf('Write results: possibleHits.txt\n');
    possHits := ParseContigHits(setname, PossContigHits, 'allarr'=writeallmsas):
    WriteResultFile(outFolder.'possibleHits.txt', possHits, 'posshits', writeallmsas);

    actuallyWriteFasta := proc(arr, writeall:boolean, fastaset)
        CallSystem('mkdir -p '.outFolder.'fasta/'.fastaset):
        limit := length(arr):
        if not writeall then limit := min(50, limit) fi:
        for j to limit do
            i := arr[j]:
            seqs := i[1]:
            labels := i[2]:
            # try to create MSA
            m := traperror(MafftMSA(seqs, labels)):
            if not type(m,string) then
                seqs := m[2]:
            fi:
            # some postprocessing of strings
            for s in seqs do
                s := ReplaceString('_', '-', s);
            od:
            WriteFasta(seqs, labels, outFolder.'fasta/'.fastaset.'/'.j.'.fa');
        od:
    end:

    # write fasta files and/or MSAs and make tarball
    if fasta then
        printf('Write results: fasta files\n');
        actuallyWriteFasta(defHits, writeallmsas, 'defhits'):
        actuallyWriteFasta(possHits, writeallmsas, 'posshits'):
        TimedCallSystem('cd '.outFolder.' && tar cvzf fasta.tgz fasta');
        TimedCallSystem('rm -rf '.outFolder.'fasta');
    fi:

    return();
end:

end: # module
