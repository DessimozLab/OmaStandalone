# Collect various data from the Orthologs Matrix algorithm.
#
#                                    Alexander Roth (Jan 206)

ConnectionStats := proc()
    # how many "relations" remains after each step of the algorithm.

    LL:=10000:  # length of list to store stats

    NofC:=Counter('Maximum of possible connections'):
    for n from 2 to length(ns) do NofC+(ns[n-1]*ns[n]) od:
    
    # how pairs and their distribution with regards
    # to top score position
    GetPairStats := proc(Conn:list)
        TotConn:=0;
        ConnDistr:=CreateArray(1..LL);
        TopDistr:=CreateArray(1..LL);
        for i to N-1 do for j from i+1 to N do 
            for k to length(Conn[i,j]) do
                lk:=length(Conn[i,j,k]);
                if lk=0 then next fi;
                TotConn:=TotConn+lk;
                ConnDistr[lk]:=ConnDistr[lk]+1;
                for m to lk do
                    for n to length(BestMatch[i,j,k]) do
                        if Conn[i,j,k,m]=BestMatch[i,j,k,n,Entry] then
                            TopDistr[n]:=TopDistr[n]+1;
                        fi;
        od od od od od;
        [TopDistr,ConnDistr]
    end:
    
    GetTopStatQVSP := proc()
        TopDistr:=CreateArray(1..LL);
        ConnDistr:=[1];   # by def of clique
        for n in Ort do
            for i to N do
                if n[i]=0 then next fi;
                for j from i+1 to N do
                    if n[j]=0 then next fi;
                    for m to length(BestMatch[i,j,n[i]]) do
                        if n[j]=BestMatch[i,j,n[i],m,Entry] then
                            TopDistr[m]:=TopDistr[m]+1;
                        fi;
        od od od od;
        [TopDistr,ConnDistr];
    end:
    
    GetConnPair := proc(Conn:list)
        TopDistr:=0;
        ConnDistr:=CreateArray(1..LL);
        for i to N-1 do for j from i+1 to N do
            TopDistr:=TopDistr+sum(length(BestMatch[i,j,k]), 
                                   k=1..length(BestMatch[i,j]));
            for k to length(Conn[i,j]) do
                lk:=length(Conn[i,j,k]);
                if lk=0 then next fi;
                ConnDistr[lk]:=ConnDistr[lk]+1;
        od od od;
        [[TopDistr],ConnDistr]
    end:
        
    PercentTop := proc(cd:list, pos:posint; prec=2:posint)
        d:=cd/max(1,sum(cd));
        round(d[pos]*100*10^prec)/(10^prec);
    end:
    
     Pstat := GetConnPair(BestMatch);
    SPstat := GetPairStats(StablePairs);
    VPstat := GetPairStats(VPairs);
    QPstat := GetTopStatQVSP();
    
    sumhist := [seq(i*histog[i], i=2..N)];
    sumhist[1] := sum(ns)-sum( histog[i]*i, i=1..N );
    sumhist := sumhist/sum(sumhist);
    
    stats := Table(
    ColAlign(seq('r',i=1..7)), border, gutter=2, 
    Row(          'Type',       'Number',            'aver degree',              'aver rank', '%1', '%2', '%3'),
    Rule,
    Row(         'Total',    NofC[value],                    '-'  ,       seq('N/A',i=1..4)),
    Row(         'Saved',      t2[value],                    '-'  ,       seq('N/A',i=1..4)),
    Row(         'Pairs', sum( Pstat[1]), ExpectedValue( Pstat[2]),       seq('N/A',i=1..4)),
    Row(  'Stable Pairs', sum(SPstat[1]), ExpectedValue(SPstat[2]), ExpectedValue(SPstat[1]), seq(PercentTop(SPstat[1],i),i=1..3)),
    Row('Verified Pairs', sum(VPstat[1]), ExpectedValue(VPstat[2]), ExpectedValue(VPstat[1]), seq(PercentTop(VPstat[1],i),i=1..3)),
    Row(  'Clique Pairs', sum(QPstat[1]), ExpectedValue(QPstat[2]), ExpectedValue(QPstat[1]), seq(PercentTop(QPstat[1],i),i=1..3))
    ):
    print(stats);

    [Pstat,SPstat,VPstat,QPstat,sumhist];
end:

ExpectedValue := proc(cd:list)
    d:=cd/max(1,sum(cd));
    sum([seq(d[i]*i,i=1..length(d))]);
end:

# compare how often the top relation have
# both the highest score and the closest distance
#
#                      Alexander Roth (Jan 2006)

SortBestMatch := proc(rel:list; acc='Score100':string)
    for i to N do for j to N do for k to ns[i] do
        if length(rel[i,j,k])>1 then
            g:=rel[i,j,k];
            if acc='Score100' then rel[i,j,k]:=sort(g, g -> -g[acc]);
            else rel[i,j,k]:=sort(g, g -> g[acc]) fi;
    fi od od od;
end:
            
ScoreDistRanking := proc(rel:list)

    AddToList := proc(relat:list) -> list;
        ret:=[];
        for i to N-1 do for j from i+1 to N do for k to ns[i] do
            if length(relat[i,j,k])>1 then
                ret:=append(ret, relat[i,j,k,1,Entry]);
        fi od od od;
        ret;
    end:
    
    c1:=Counter('Rankings that do coincide'):
    c2:=Counter('Rankings that do NOT coincide'):
    # sort according to score and distance and append the entry number of the
    # leading pair to two lists.
    SortBestMatch(rel, 'Score100'):
    scoli:=AddToList(rel);
    SortBestMatch(rel, 'PamDist100'):
    disli:=AddToList(rel);
    
    if length(scoli)<>length(disli) then error('lengths do not match') fi;
    
    # compare the lists to see how often they coincide.
    for i to length(scoli) do
        if scoli[i]=disli[i] then c1+1 else c2+1 fi;
    od;
    print(c1,c2);
end:

ScoreDistData := proc(rel:list; upperdist100=100001:numeric)
    data:=[];
    for i to N-1 do for j from i+1 to N do for k to ns[i] do
        if length(rel[i,j,k])>0 then
            for l to length(rel[i,j,k]) do
                if rel[i,j,k,l,'PamDist100']>upperdist100 then next fi;
                data:=append(data, [rel[i,j,k,l,'PamDist100'], rel[i,j,k,l,'Score100']]);
                #data:=append(data, [rel[i,j,k,l,'PamDist100'], rel[i,j,k,l,'Score100']/rel[i,j,k,l,'SumLengths']]);
    od fi od od od;
    data;
end:

