module external DetectParallelInfo, ParallelInfo, ParallelInfo_print:

ParallelInfo := proc(NrParallelProc:posint, ProcNr:posint)
    return(noeval(procname(args))):
end:
ParallelInfo_print := proc(pinf) option internal;
    printf('Process %d on %s: job nr %d of %d\n', getpid(), hostname(), 
        pinf['ProcNr'], pinf['NrParallelProc']);
end:
CompleteClass(ParallelInfo):

LSF_Platform := proc()
    jobidx := getenv('LSB_JOBINDEX');
    # if not a jobarray, assume single process and warn user.
    if jobidx='' or jobidx='0' then 
        jobidx:=1;
        NrParallelProc := 1;
        warning('not run as job-array. Will assume it is a single process.');
    else
        jobidx := parse(jobidx);
        jobId := getenv('LSB_JOBID');
        jobsum := TimedCallSystem('bjobs -A '.jobId);
        if jobsum[1]<>0 then 
            error('cannot call ''bjobs'' command successfully'); 
        fi:
        sndLine := SplitLines(jobsum[2])[2];
        re := MatchRegex('^[[:digit:]]\+[[:blank:]]\+[^[:blank:]]\+[[:blank:]]\+[^[:blank:]]\+[[:blank:]]\+([[:digit:]]\+)', sndLine);
        if length(re)<2 then error('cannot extract total number of jobs'); fi:
        NrParallelProc := parse(re[2]);
    fi:
    if jobidx > NrParallelProc then
        error('require range from 1-x of jobarray.');
    fi:
    return(ParallelInfo(NrParallelProc, jobidx));
end:

SunGrid_Platform := proc()
    jobidx := getenv('SGE_TASK_ID');
    # if not a jobarray, assume single process and warn user.
    if jobidx='' then 
        jobidx:=1;
        NrParallelProc := 1;
        warning('not run as job-array. Will assume it is a single process.');
    else
        jobidx := parse(jobidx);
        # TODO: find out how to compute NrOfParallelJobs
        NrParallelProc := getenv('SGE_TASK_LAST');
        if NrParallelProc<>'' then
            NrParallelProc := parse(NrParallelProc);
        else
            NrParallelProc := 1;
        fi:
    fi:
    if jobidx > NrParallelProc then
        error('require range from 1-x of jobarray.');
    fi:
    return(ParallelInfo(NrParallelProc, jobidx));
end:

Slurm_Platform := proc()
    jobidx := getenv('SLURM_ARRAY_TASK_ID');
    # if not a jobarray, assume single process and warn user.
    if jobidx = '' then
        jobidx := 1;
        NrParallelProc := 1;
        warning('not run as job-array. Will assume it is a single process.');
    else
        jobidx := parse(jobidx);
        jobId := getenv('SLURM_ARRAY_JOB_ID');
        jobsum := TimedCallSystem('squeue -j '.jobId);
        if jobsum[1]<>0 then
            error('cannot call ''squeue'' command successfully');
        fi:
        sndLine := SplitLines(jobsum[2]);
        NrParallelProc := length(sndLine) -1;
    fi;
    if jobidx > NrParallelProc then
        error('require range from 1-x of jobarray.');
    fi:
    return(ParallelInfo(NrParallelProc, jobidx));
end:

DetectParallelInfo := proc()
    if getenv('LSB_JOBID')<>'' then
        return(LSF_Platform());
    elif getenv('SGE_ROOT')<>'' then
        return(SunGrid_Platform());
    elif getenv('SLURM_ARRAY_JOB_ID') <> '' then
        return(Slurm_Platform());
    elif type(NR_PROCESSES,posint) then
        if not type(THIS_PROC_NR,posint) then 
            error('oma standalone is not propperly started. bye.');
        fi:
        return(ParallelInfo(NR_PROCESSES,THIS_PROC_NR));
    else 
        return(ParallelInfo(1,1));
    fi:
end:

end: #module
