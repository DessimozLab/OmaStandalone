# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/2.0/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is OMA standalone.
#
# The Initial Developer of the Original Code is CBRG Research Group; 
# ETH Zurich; Switzerland.
# Portions created by the Initial Developer are Copyright (C) 2005-2013
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Christophe Dessimoz <cdessimoz@inf.ethz.ch>
#   Adrian Altenhoff <adrian.altenhoff@inf.ethz.ch>
#   Stefan Zoller <stefan.zoller@inf.ethz.ch>
#   Adrian Schneider <adrian.schneider@inf.ethz.ch>
#   Alexander Roth <alexander.roth@inf.ethz.ch>
#   Gaston Gonnet <gonnet@inf.ethz.ch>
#
# ***** END LICENSE BLOCK *****
# Set(quiet):
##############################################################################
#       ___           ___           ___     
#      /\  \         /\__\         /\  \    
#     /::\  \       /::|  |       /::\  \   
#    /:/\:\  \     /:|:|  |      /:/\:\  \  
#   /:/  \:\  \   /:/|:|__|__   /::\~\:\  \ 
#  /:/__/ \:\__\ /:/ |::::\__\ /:/\:\ \:\__\
#  \:\  \ /:/  / \/__/~~/:/  / \/__\:\/:/  /
#   \:\  /:/  /        /:/  /       \::/  / 
#    \:\/:/  /        /:/  /        /:/  /  
#     \::/  /        /:/  /        /:/  /   
#      \/__/         \/__/         \/__/    
# 
#       Stand-alone version
#          (c) CBRG, ETH Zurich, 2004-2011
##############################################################################
# Usage
#
#   This script identifies orthologs among genomes using the OMA procedure.
#   (http://omabrowser.org).
#
#   If you received this script per standalone installer for OMA, please have
#   also a look at the included README.oma file in the installation folder
#   (default location is /usr/local/oma).
#
#   - Run this script from the same directory.
#   - Script parameters are set in parameters.drw in the same directory
#   - Each genome should have its own fasta file (filename ending with .fa)
#     and be placed in a directory called DB/ 
#
##############################################################################

Set(gc=5e7):  
SetRandSeed():  
GetStats := true;

# Read libraries
if assigned(libdir) then
    ReadProgram( libdir . 'darwinit'):
else
    ReadProgram('lib/darwinit'):
fi:

# Convert FASTA databases to darwin databases
print('Starting database conversion and checks...');

if not assigned(Datasets) then
    G := TimedCallSystem('find -L DB -name "*.fa" -print')[2];
    G := SearchDelim('\n',G);
else
    G := Datasets;
fi:
if not type(NP,posint) then NP := 1 fi;

GS := table();
DBs := genomes := isContig := [];
if not ReuseCachedResults then
    CallSystem('rm -rf Cache'); 
fi;
CallSystem('mkdir -p Cache/DB');
for g in G do
    off := SearchAllString('/', g);
    gname := g[off[-1]+1..-1];   
    if SearchString('contig',gname) > -1 then
        isContig := append(isContig,true);
    else
        isContig := append(isContig,false);
    fi;
    off := SearchString('.',gname);
    gname := gname[1..off];
    if SearchArray(gname,genomes) <> 0 then
        error('More than one genome labelled '.gname);
        quit;
    fi;
    if length(genomes) = 9999 then
        print('too many genomes');
    fi;
    genomes := append(genomes,gname);

    # test if cached:
    if length(FileStat('Cache/DB/'.gname.'.db')) > 0 then
        DB := ReadDb('Cache/DB/'.gname.'.db');
        if type(DB,database) then
            GS[gname] := GenomeSummary(DB);
            DBs := append(DBs,DB); 
            next;
        fi;
    fi;

    ##
    code := 'S'.sprintf('%04d',length(genomes));
    input := ReadFastaWithNames(g);

    OpenWriting('Cache/DB/'.gname.'.db');
    printf('<5LETTERNAME>%s</5LETTERNAME>\n',code);
    print('<OS>Unknown</OS>');
    print('<KINGDOM>Unknown</KINGDOM>');
    
    if length(input[1]) <> length(input[2]) then 
        OpenWriting(previous);
        error('Fasta DB length missmatch') 
    fi;
    ML := If(isContig[-1],MinSeqLenContig,MinSeqLen);
    for i to length(input[1]) do
        s := uppercase(input[1,i]):
        # minimal check of sequences
        if length(s) < ML then
            OpenWriting(previous);
            printf( 
            'Warning: Sequence %s (%s) is less than MinSeqLen(Contig)=%d AA '
            .'long. Ignored. \n',
                input[2,i], gname, ML
            );
            OpenAppending('Cache/DB/'.gname.'.db');
            next;
        fi;
        for j to length(s) do
            aa := AToInt(s[j]);
            if aa < 1 or aa > 21 then
                OpenWriting(previous);
                error(printf('Unknown character: %s (in %s, %s)', 
                    s[j], input[2,i], gname));
                quit;
            fi;
        od;
        printf('<E><ID>%s</ID><SEQ>%s</SEQ></E>\n',
            ReplaceString('\t','',input[2,i]) , s);
    od:
    OpenWriting(previous);
    DB := ReadDb('Cache/DB/'.gname.'.db');
    GS[gname] := GenomeSummary(DB);
    DBs := append(DBs,DB); 
od:
if length(genomes) < 2 then
    printf('\n\n'
          .'%d genome found... make sure that your genomes (in fasta format)\n'
          .'are located in a directory called "DB", itself located in\n'
          .'the present directory.\n\n'
         , length(genomes));
    quit;
fi;

# check whether we find AllAll-files which have been computed using a 
# different NP. In that case, warn the user and/or stop
if length(FileStat('Cache/AllAll'))>0 then
t := TimedCallSystem('find Cache/AllAll -type f')[2];
files := [seq(f[1..-2], f=SplitLines(t))]:
for file in files do
    b := SearchAllString('-', file);
    if b = [] then next fi:
    b := b[-1]:
    e := If(file[-3..-1]='.gz', -4, -1);
    if parse(file[b+1..e])<>NP then
        printf('\n\n'
            .'WARNING: found allall-files which have not the same value '
            .'for ''NP''.\n'
            .'  If you continue, the previous results will be not be used.\n');
        sleep(5);
        break;
    fi:
od:
fi:
    
if NP>1 then sleep( Rand(1..10) ) fi:

##############################################################################
# All-against-all
#   assign name1, name2, db1, db2

print('\n\n****\n\nStarting the all-against-all phase...\n');
print('Note, if you want to parallelize this process, you may start ',
    'several instances of OMA from the same directory now.\n');

CreateDayMatrices();
DM := DayMatrix(224):
NumberFormat := '%.10g':
JustScoreBound := MinScore;

tot := length(genomes)*(length(genomes)+1)/2*NP;
totAls := [seq( seq( seq( DBs[g1,TotEntries]/NP*DBs[g2,TotEntries], NP), g2=g1..length(genomes)), g1=1..length(genomes))];
c1 := 0:
for g1 to length(genomes) do 
    for g2 from g1 to length(genomes) do
        # Phase 0
        db1 := DBs[g1];
        db2 := DBs[g2]; 
        name1 := genomes[g1];
        name2 := genomes[g2];
        n1 := db1[TotEntries]:
        n2 := db2[TotEntries];
        if n1 > n2 or n1=n2 and name1 > name2 then
            t := db1;  db1 := db2;  db2 := t;
            t := name1;  name1 := name2;  name2 := t;
            t := n1;  n1 := n2;  n2 := t;
        fi:
        Seqs1 := CreateArray(1..n1):
        Seqs2 := CreateArray(1..n2):
        DB := db1:
        for i1 to n1 do Seqs1[i1] := SearchTag('SEQ',Entry(i1)) od:
        DB := db2:
        for i2 to n2 do Seqs2[i2] := SearchTag('SEQ',Entry(i2)) od:

        # Phase 1
        CallSystem('mkdir -p Cache/AllAll/'.name1);
        # skip if 1-chunk archive already present (import from OMA AxA)
        fn1chunk := sprintf('Cache/AllAll/%s/%s.gz', name1, name2);
        if length(FileStat(fn1chunk))>0 then 
            printf('Pair %s/%s already computed (probably imported). Skipped.\n',
                name1, name2 );
            next;
        fi;

        partLen := ceil( n1/NP ); 
        for part to NP do
            c1 := c1+1;
            # skip if cached or already computed
            fn := sprintf('Cache/AllAll/%s/%s_%d-%d', name1, name2, part, NP);
            if length(FileStat(fn))>0 or length(FileStat(fn.'.gz'))>0 then
                printf('Pair %s/%s part %d of %d already computed. Skipped.\n',
                    name1, name2, part, NP);
                next;
            fi:

            printf('[pid %6d]: Computing %s vs %s (Part %d of %d)\n', 
                getpid(), name1, name2, part, NP);
            OpenWriting(fn);
            printf( '# AllAll of %s vs %s (Part %d of %d)\n',
                name1,name2,part,NP );
            OpenWriting(previous);
    
            t0 := UTCTime():
            res := []:
            c2 := 0;
            tot2 := partLen*n2;
            for i1 from (part-1)*partLen+1 to min(n1, part*partLen) do 

                len1 := length(Seqs1[i1]);
                for i2 from If( name1=name2, i1+1, 1 ) to n2 do
                    c2 := c2+1;
                    if mod(c2,50000)=0 then
                        printf('   [pid %6d]: %.2f%% complete, time left for this '.
                            'part=%.1fh, %.1f%% of AllAll done\n',
                            getpid(),100*c2/tot2,tot2/c2*(UTCTime()-t0)/3600,
                            100*( (c1-1+c2/tot2)/tot ));
                    fi:
                    len2 := length(Seqs2[i2]);
                    dps := DynProgScore(Seqs1[i1],Seqs2[i2],DM,JustScoreShort);
                    if dps[1] >= .75*MinScore then
                        a := Align(Seqs1[i1],Seqs2[i2],DMS);
                        if a[Score] < MinScore or min(a[Length1],a[Length2]) <
                                    max(30,0.3*min(len1,len2)) then next fi;
                        i := GetOffset(a[Seq1])-GetOffset(Seqs1[i1]);
                        ran1 := i+1 .. i+a[Length1];
                        i := GetOffset(a[Seq2])-GetOffset(Seqs2[i2]);
                        ran2 := i+1 .. i+a[Length2];
                        res := append(res,[i1,i2,a[Score],a[PamDistance],
                                    ran1,ran2,a[PamVariance]] );
                    fi;
                    if length(res)>1e5 then 
                        WriteMatches(fn, res);
                        res := []:
                    fi:
                od;
            od:
            WriteMatches(fn,res):

            drt := UTCTime()-t0:
            dat := time():
            OpenAppending(fn);
            printf('# %s: %ds/%ds active = %.1f%%  %s\n',hostname(),round(dat),
                round(drt), 100*dat/drt,If(dat/drt<0.7,'SLOW!',''));
            OpenAppending(previous);
            # Compress file
            CallSystem('gzip -9f '.fn);
            if c2 > 0 then
                printf('Finished %s vs %s (Part %d of %d)\n'.
                '  %.1f%% of AllAll done, estimated remaining time:'
                .' %.1fh\n\n', name1,name2,part,NP, 
                100*c1/tot, drt*sum(totAls[c1..tot])/c2/3600);
            else
                printf('Finished %s vs %s (Part %d of %d)\n',
                    name1,name2,part,NP);
            fi;
        od: 
    od; 
od:

## Parallel version:
## At this point, check whether all files are ready. If not
## exit (another process will pick from there on!)
f := TimedCallSystem('find Cache/AllAll -type f | grep -v ".gz"')[2]:
if length(f) > 0 then
    print('** At least 1 process appears to be still computing the all-vs-all.');
    print('** The following file(s) is (are) not yet completed:');
    print(f);
    print('** If no other process is running, delete these files and restart.');
    quit;
fi:


##############################################################################
# Candidate Pairs

print('\n\n****\n\nReading the all-against-all files...\n');

N := length(genomes):
ns := CreateArray(1..N):
Lengths := CreateArray(1..N):
for i to N do
    if GS[genomes[i]]='unassigned' then
        lprint(genomes[i],'missing GenomeSummary information');  quit fi;
    t := GS[genomes[i],EntryLengths];
    ns[i] := length(t);
    Lengths[i] := t
od:
t1 := Counter('RefinedMatches structures read'):
t2 := Counter('Matches read'):
t3 := Counter('files read'):
t4 := Counter('Matches of genomes against themselves'):
t5 := Counter('Matches above parameters');
t6 := Counter('empty all-all'):
t7 := Counter('Number of matches discarded below MinSeqLen');

# Read the BestMatch from all x all files #

    BestMatch := CreateArray(1..N,1..N):
    for i to N do for j from i to N do
        BestMatch[i,j] := CreateArray(1..ns[i],[]);
        if j>i then BestMatch[j,i] := CreateArray(1..ns[j],[]) fi;
        if ns[i] < ns[j] or ns[i]=ns[j] and genomes[i] < genomes[j] then
            g1 := i;  g2 := j else g2 := i;  g1 := j fi;
        BestMatch1 := BestMatch[g1,g2];  BestMatch2 := BestMatch[g2,g1];
        t3+1;
        Exclude1 := Exclude2 := {}:
        # if there exist a 1-chunk archive, process it with higher priority
        fn1chunk := sprintf('Cache/AllAll/%s/%s.gz',genomes[g1],genomes[g2]);
        if length(FileStat(fn1chunk)) > 0 then
            ReadProgram(fn1chunk);
        else
            for part to NP do 
                fn := sprintf('Cache/AllAll/%s/%s_%d-%d',genomes[g1],genomes[g2],
                    part, NP);
                ReadProgram( fn );
            od:
        fi;
        # no Pairs should be cut for being below the Scoretol, as those
        # may serve to break a stable pair
        sij := sum(length(BestMatch[i,j,k]), k=1..length(BestMatch[i,j]));
        sji := sum(length(BestMatch[j,i,k]), k=1..length(BestMatch[j,i]));
        t5+max(sij,sji);
        if sij=0 or sji=0 then
            t6+1;
            # relax in case of mitochondion genome or synthetic evolution
            warning('empty all-all for '.genomes[g1].' '. genomes[g2] ) 
        fi;
        for k to length(BestMatch[i,j]) do
            if BestMatch[i,j,k] <> [] then
            BestMatch[i,j,k] := compress(BestMatch[i,j,k]) fi od;
        for k to length(BestMatch[j,i]) do
            if BestMatch[j,i,k] <> [] then
            BestMatch[j,i,k] := compress(BestMatch[j,i,k]) fi od;
        printf( '# %s vs %s done, (%d/%d)\n', genomes[g1],genomes[g2], 
            sij, sji );
    od od:



##############################################################################
# Verification of stable pairs and clique building or esprit 

cput_mid := time(); time_mid := UTCTime();
printlevel := 3:
NumberFormat := '%.8g':
params := [MinScore, LengthTol, StablePairTol, VerifiedPairTol, UseEsprit]:
ParamSet := [];

if UseEsprit then
    print('\n\n****\n\nRunning ESPRIT for the detection of split-genes\n');
    Esprit([MinProbContig, MinBestScore, DistConfLevel,
            true, MaxContigOverlap]):
    WriteEspritResults();
else
    print('\n\n****\n\nIdentification of Stable-Pairs (Putative Orthologs)\n');
    Ort := OrthologousMatrix( op(params) ):

    if DoHierarchicalGroups=true then
        printlevel := 1:
        if SpeciesTree='estimate' then
            speciesTree := BuildSpeciesTree( Ort );
        elif SpeciesTree='lineage' then
            speciesTree := NULL:
        elif type(SpeciesTree,string) then
            speciesTree := ParseNewickTree(SpeciesTree,
                'defaultBranchLength'=1):
        fi:
        # call hierarchical group procedure
        HOG := traperror(HierarchicalGroups(ReachabilityCutoff,speciesTree));
    fi:
    # # Retrieve all IDs
    # # Create File MapSeqNum-ID:
    CallSystem('rm -rf Output; mkdir -p Output/PairwiseOrthologs');
    IDtable := CreateArray(1..N);
    OpenWriting('Output/Map-SeqNum-ID.txt');
    print('\#Format: genome<tab>sequence number<tab>id');
    for i to N do
        DB := DBs[i];
        tmp := CreateArray(1..ns[i]);
        for j to DB[TotEntries] do
            tmp[j] := SearchTag('ID',Entry(j));
            printf('%s\t%d\t%s\n',genomes[i],j,tmp[j]);
        od;
        IDtable[i] := tmp;
    od:
    OpenWriting(previous);


    ############################################################################
    # Store results
    Set('printgc'=false);
    print('\n\n****\n\nStoring results\n');

    if lasterror <> 'lasterror' then
        print('Abort because of error: '.lasterror);
        # quit;
    fi:

    OGtable := CreateArray(1..N):
    for i to N do OGtable[i] := CreateArray(1..ns[i]); od:
    for r to length(Ort) do
        for k to N do
            t := Ort[r,k];
            if t <> 0 then 
                OGtable[k,t] := r;
            fi;
        od;
    od:

    # Store the pairwise orthologs
    for i to N do for j from i+1 to N do
        if ns[i] < ns[j] or ns[i]=ns[j] and genomes[i] < genomes[j] then
            g1 := i;  g2 := j else g2 := i;  g1 := j fi;
            OpenWriting('Output/PairwiseOrthologs/'.genomes[g1].'-'.genomes[g2]
                .'.txt');
        printf('\# Format: Protein 1<tab>Protein 2<tab>Protein ID1<tab>ProteinID2'
             .'<tab>Orthology type<tab>OMA group (if any)\n');
        printf('\# Every pair is listed only once, and in no particular order.\n');
        printf('\# The map between sequence number and ID are given\n');
        printf('\# in the file "Map-SeqNum-ID.map\n');

        for k to ns[g1] do
            vp := decompress(VPairs[g1,g2,k]);
            typ2 := If(length(vp)>1,'many','1');
            for l in vp do
                # if only 1 in target -> :1, else :many
                # l
                typ1 := If(length(decompress(VPairs[g2,g1,l]))>1,'many','1');
                printf('%d\t%d\t%s\t%s\t%s:%s\t%s\n',
                    k,l,
                    IDtable[g1,k],
                    IDtable[g2,l],
                    typ1, typ2,
                    If(OGtable[g1,k]=OGtable[g2,l] and OGtable[g1,k] <> 0, 
                        string(OGtable[g1,k]),
                        '')
                );
            od;
        od:
        OpenWriting(previous);
    od;od:

    # Store the groups of orthologs
    WriteMatrix(Ort,'Output/OrthologousMatrix.txt');
    WriteGroups(Ort,'Output/OrthologousGroups.txt');
    # store orthologous groups in orthoxml format
    WriteOrthoXML( Ort, 'Output/OrthologousGroups.orthoxml');
    
    # developpment code
    if type(MergeOMAGroups, procedure) then
        mergedOMAGroups := MergeOMAGroups(Ort, VPairs);
        WriteOrthoXML( mergedOMAGroups, 'Output/MergedOMAGroups.orthoxml');
        WriteMatrix( mergedOMAGroups, 'Output/MergedOMAMatrix.txt');
        WriteGroups( mergedOMAGroups, 'Output/MergedOMAGroups.txt');
    fi:

    # store all orthologous groups in fasta format
    CallSystem('mkdir Output/OrthologousGroupsFasta');
    for r to length(Ort) do
        OpenWriting(sprintf('Output/OrthologousGroupsFasta/OG%d.fa',r));
        for l to N do
            if Ort[r,l] <> 0 then
                DB := DBs[l];
                e := Entry(Ort[r,l]);
                printf('>%s\n%s\n',
                    genomes[l], SearchTag('SEQ',Entry(e)) );
            fi;
        od;
        OpenWriting(previous);
    od:
    
    # store hierarchical groups if computed
    if DoHierarchicalGroups=true then
        WriteOrthoXML( HOG, 'Output/HierarchicalGroups.orthoxml');
        if SpeciesTree='estimate' then
            OpenWriting('Output/EstimatedSpeciesTree.nwk');
            prints( Tree_Newick(speciesTree) .';' );
            OpenWriting(previous):
        fi:
    fi:

fi:

print('\n\n***\n\nDone!!\n\n');
