# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/2.0/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is OMA standalone.
#
# The Initial Developer of the Original Code is CBRG Research Group; 
# ETH Zurich; Switzerland.
# Portions created by the Initial Developer are Copyright (C) 2005-2013
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Christophe Dessimoz <cdessimoz@inf.ethz.ch>
#   Adrian Altenhoff <adrian.altenhoff@inf.ethz.ch>
#   Stefan Zoller <stefan.zoller@inf.ethz.ch>
#   Adrian Schneider <adrian.schneider@inf.ethz.ch>
#   Alexander Roth <alexander.roth@inf.ethz.ch>
#   Gaston Gonnet <gonnet@inf.ethz.ch>
#
# ***** END LICENSE BLOCK *****
# Set(quiet):
##############################################################################
#       ___           ___           ___     
#      /\  \         /\__\         /\  \    
#     /::\  \       /::|  |       /::\  \   
#    /:/\:\  \     /:|:|  |      /:/\:\  \  
#   /:/  \:\  \   /:/|:|__|__   /::\~\:\  \ 
#  /:/__/ \:\__\ /:/ |::::\__\ /:/\:\ \:\__\
#  \:\  \ /:/  / \/__/~~/:/  / \/__\:\/:/  /
#   \:\  /:/  /        /:/  /       \::/  / 
#    \:\/:/  /        /:/  /        /:/  /  
#     \::/  /        /:/  /        /:/  /   
#      \/__/         \/__/         \/__/    
# 
#       Stand-alone version
#          (c) CBRG, ETH Zurich, 2004-2011
##############################################################################
# Usage
#
#   This script identifies orthologs among genomes using the OMA procedure.
#   (http://omabrowser.org).
#
#   If you received this script per standalone installer for OMA, please have
#   also a look at the included README.oma file in the installation folder
#   (default location is /usr/local/oma).
#
#   - Run this script from the same directory.
#   - Script parameters are set in parameters.drw in the same directory
#   - Each genome should have its own fasta file (filename ending with .fa)
#     and be placed in a directory called DB/ 
#
##############################################################################

Set(gc=5e8):  
SetRandSeed():  
GetStats := true;

# Read libraries
if assigned(libdir) then
    ReadProgram( libdir . 'darwinit'):
else
    ReadProgram('lib/darwinit'):
fi:

# Convert FASTA databases to darwin databases
print('Starting database conversion and checks...');

if not assigned(Datasets) then
    G := TimedCallSystem('find -L DB -name "*.fa" -print')[2];
    G := sort(SearchDelim('\n',G));
else
    G := Datasets;
fi:

# get nr of total parallel process and number of this job.
pinf := traperror(DetectParallelInfo()):
if pinf=lasterror then
    printf('ERROR: %a\n', pinf);
    exit(1);
fi:
print(pinf);

# if not job nr 1, wait until conversion of DBs are done.
convDone := proc() 
    filename := 'Cache/conversion.done';
    if nargs=0 then 
        return(FileExists(filename));
    elif nargs=1 and args[1] then
        OpenWriting(filename); 
        printf('# finished at %s on %s (pid %d), time %f\n', date(), hostname(), 
            getpid(), time());
        OpenWriting(previous);
    fi:
end:
if pinf['ProcNr']>1 then
    for k to 5*length(G) while not convDone() do 
        sleep(min(20, ceil(Rand()*2^k))) 
    od:
    if not convDone() then 
        printf('job %d [pid %d]: waiting for too long. abort.\n', pinf['ProcNr'], getpid());
        exit(1);
    fi:
fi:

GS := table();
DBs := genomes := isContig := [];
if pinf['ProcNr']=1 and not ReuseCachedResults then
    CallSystem('rm -rf Cache'); 
fi;
CallSystem('mkdir -p Cache/DB');
for g in G do
    off := SearchAllString('/', g);
    gname := g[off[-1]+1..-1];   
    if SearchString('contig',gname) > -1 then
        isContig := append(isContig,true);
    else
        isContig := append(isContig,false);
    fi;
    off := SearchString('.',gname);
    gname := gname[1..off];
    if SearchArray(gname,genomes) <> 0 then
        error('More than one genome labelled '.gname);
        quit;
    fi;
    if length(genomes) = 9999 then
        print('too many genomes');
    fi;
    genomes := append(genomes,gname);

    # compute sha2 of fasta file.
    checksum := sha2(ReadRawFile(g))[1..16]:

    # test if cached:
    if FileExists('Cache/DB/'.gname.'.db') then
        DB := ReadDb('Cache/DB/'.gname.'.db');
        if type(DB,database) then
            GS[gname] := GenomeSummary(DB);
            DBs := append(DBs,DB); 
            fcheck := SearchTag('FASTACHECKSUM', DB['string']);
            if fcheck<>'' and checksum<>fcheck then
                error('cached genome ('.gname.') differs from fasta file');
            fi:
            next;
        fi;
    fi;

    ##
    code := 'S'.sprintf('%04d',length(genomes));
    input := ReadFastaWithNames(g);

    OpenWriting('Cache/DB/'.gname.'.db');
    printf('<5LETTERNAME>%s</5LETTERNAME>\n',code);
    printf('<OS>Unknown</OS>\n');
    printf('<KINGDOM>Unknown</KINGDOM>\n');
    printf('<FASTACHECKSUM>%s</FASTACHECKSUM>\n', checksum);
    if length(input[1]) <> length(input[2]) then 
        OpenWriting(previous);
        error('Fasta DB length missmatch') 
    fi;
    ML := If(isContig[-1],MinSeqLenContig,MinSeqLen);
    for i to length(input[1]) do
        s := uppercase(input[1,i]):
        # minimal check of sequences
        if length(s) < ML then
            warning( sprintf( 
                'Sequence %s (%s) is less than MinSeqLen(Contig)=%d AA'.
                'long. Ignored. \n',
                input[2,i], gname, ML));
            next;
        fi;
        c_toX := 0;
        for j to length(s) do
            aa := AToInt(s[j]);
            if aa < 1 or aa > 21 then
                warning(sprintf('Unknown character: %s (in %s, %s pos %d) --> X', 
                    s[j], input[2,i], gname, j));
                s[j] := 'X';
                c_toX := c_toX+1;
            fi;
        od;
        if c_toX>=5 and c_toX>.05*length(s) then
            warning('Too many unknwon chars in %s, %s. skipping.',
                input[2,i],gname);
            next;
        fi:
        tmpID := ReplaceString('\t','',input[2,i]);
        tmpID := ReplaceString('<','',tmpID);
        tmpID := ReplaceString('>','',tmpID);
        printf('<E><ID>%s</ID><SEQ>%s</SEQ></E>\n', tmpID, s);
    od:
    OpenWriting(previous);
    DB := ReadDb('Cache/DB/'.gname.'.db');
    GS[gname] := GenomeSummary(DB);
    DBs := append(DBs,DB); 
od:
convDone(true); # signal other processes to start.
NG := length(genomes):
if NG < 2 then
    printf('\n\n'
          .'%d genome found... make sure that your genomes (in fasta format)\n'
          .'are located in a directory called "DB", itself located in\n'
          .'the present directory.\n\n', NG);
    quit;
fi;
 

##############################################################################
# All-against-all
#   assign name1, name2, db1, db2
CreateDayMatrices();
DM := DayMatrix(224):
NumberFormat := '%.10g':
JustScoreBound := MinScore;

NumberOfAlignments := proc(name1:string,name2:string)
    if name1=name2 then
        nrAlignments := GS[name1,TotEntries]*(GS[name1,TotEntries]-1)/2;
    else
        nrAlignments := GS[name1,TotEntries]*GS[name2,TotEntries];
    fi:
    return(nrAlignments);
end:

NumberOfJunks := proc(name1, name2)
    return(ceil(NumberOfAlignments(name1, name2)/AlignBatchSize));
end:

UpperTriangInd2Tuple := proc(index, N)
    c := index; m := 1;
    while c-N+m > 0 do
        c := c-N+m;
        m := m+1;
    od:
    return([m, c+m]);
end:

FullInd2Tuple := proc(index, N)
    m := floor((index-1)/N);
    c := index - m*N;
    return([m+1,c]);
end:

RangeOfJunk_iterator := proc(x)
    name1 := x[1]; name2 := x[2]; junk:= x[3];
    totJunks := NumberOfJunks(name1, name2);
    if not type(junk,posint) or junk>totJunks then
        error('invalid junk number: '.junk)
    fi:
    all := NumberOfAlignments(name1, name2);
    first := floor((junk-1)*all/totJunks)+1;
    last := floor(junk*all/totJunks);
    if name1=name2 then 
        for index from first to last do
            iterate( UpperTriangInd2Tuple(index, GS[name1,TotEntries]));
        od:
    else
        for index from first to last do
            iterate( FullInd2Tuple(index, GS[name2,TotEntries]));
        od:
    fi:
end:
RangeOfJunk := noeval(RangeOfJunk):

IsMyJob := proc(name1, name2, junk)
    return( evalb(mod( hash([name1,name2,junk]), 
            pinf['NrParallelProc'] ) = pinf['ProcNr']-1) ); 
end:


tot := [seq(seq(NumberOfJunks(genomes[g1],genomes[g2]),g2=g1..NG), g1=1..NG)]; 
c1 := 0:
for g1 to NG do 
    for g2 from g1 to NG do
        # Phase 0
        db1 := DBs[g1];
        db2 := DBs[g2]; 
        name1 := genomes[g1];
        name2 := genomes[g2];
        n1 := db1[TotEntries]:
        n2 := db2[TotEntries];
        if n1 > n2 or n1=n2 and name1 > name2 then
            t := db1;  db1 := db2;  db2 := t;
            t := name1;  name1 := name2;  name2 := t;
            t := n1;  n1 := n2;  n2 := t;
        fi:
        Seqs1 := CreateArray(1..n1):
        Seqs2 := CreateArray(1..n2):
        DB := db1:
        for i1 to n1 do Seqs1[i1] := SearchTag('SEQ',Entry(i1)) od:
        DB := db2:
        for i2 to n2 do Seqs2[i2] := SearchTag('SEQ',Entry(i2)) od:

        # Phase 1
        CallSystem('mkdir -p Cache/AllAll/'.name1);
        # skip if 1-chunk archive already present (import from OMA AxA)
        fn1chunk := sprintf('Cache/AllAll/%s/%s.gz', name1, name2);
        if FileExists(fn1chunk) then 
            printf('Pair %s/%s already computed (probably imported). Skipped.\n',
                name1, name2 );
            next;
        fi;

        nrJunks := NumberOfJunks(name1, name2);
        for part to nrJunks do
            c1 := c1+1;
            if not IsMyJob(name1,name2,part) then next fi:

            # skip if cached or already computed
            fn := sprintf('Cache/AllAll/%s/%s_%d-%d', name1, name2, part, nrJunks);
            if FileExists(fn) or FileExists(fn.'.gz') then
                printf('Pair %s/%s part %d of %d already computed. Skipped.\n',
                    name1, name2, part, nrJunks);
                next;
            fi:

            printf('[pid %6d]: Computing %s vs %s (Part %d of %d)\n', 
                getpid(), name1, name2, part, nrJunks);
            OpenWriting(fn);
            printf( '# AllAll of %s vs %s (Part %d of %d); pid %d; %s\n',
                name1, name2, part, nrJunks, getpid(), hostname() );
            OpenWriting(previous);
    
            t0 := UTCTime():
            res := []:
            c2 := 0;
            algnInRange := min(AlignBatchSize,NumberOfAlignments(name1,name2));
            
            # iterate over all the protein pairs in this junk and compute alignment
            for proteinPair in RangeOfJunk(name1, name2, part) do
                i1 := proteinPair[1]; 
                i2 := proteinPair[2];
                
                len1 := length(Seqs1[i1]);
                len2 := length(Seqs2[i2]);
                c2 := c2+1;
                if mod(c2,50000)=0 then
                    printf('   [pid %6d]: %.2f%% complete, time left for this '.
                        'part=%.1fh, %.1f%% of AllAll done\n',
                        getpid(),100*c2/algnInRange,algnInRange/c2*(UTCTime()-t0)/3600,
                        100*( (c1-1+c2/algnInRange)/sum(tot) ));
                fi:
                dps := DynProgScore(Seqs1[i1],Seqs2[i2],DM,JustScoreShort);
                if dps[1] >= .75*MinScore then
                    a := Align(Seqs1[i1],Seqs2[i2],DMS);
                    if a[Score] < MinScore or min(a[Length1],a[Length2]) <
                                max(30,0.3*min(len1,len2)) then next fi;
                    i := GetOffset(a[Seq1])-GetOffset(Seqs1[i1]);
                    ran1 := i+1 .. i+a[Length1];
                    i := GetOffset(a[Seq2])-GetOffset(Seqs2[i2]);
                    ran2 := i+1 .. i+a[Length2];
                    res := append(res,[i1,i2,a[Score],a[PamDistance],
                                ran1,ran2,a[PamVariance]] );
                fi;
                if length(res)>1e5 then 
                    WriteMatches(fn, res);
                    res := []:
                fi:
            od:
            WriteMatches(fn,res):

            drt := UTCTime()-t0:
            dat := time():
            OpenAppending(fn);
            printf('# %s: %ds/%ds active = %.1f%%  %s\n',hostname(),round(dat),
                round(drt), 100*dat/drt,If(dat/drt<0.7,'SLOW!',''));
            OpenAppending(previous);
            # Compress file
            CallSystem('gzip -9f '.fn);
            if c2 > 0 then
                printf('Finished %s vs %s (Part %d of %d)\n'.
                '  %.1f%% of AllAll done, estimated remaining time:'
                .' %.1fh\n\n', name1,name2,part,nrJunks, 
                100*c1/sum(tot), algnInRange * drt * sum(tot[c1..-1])/c2/3600);
            else
                printf('Finished %s vs %s (Part %d of %d)\n',
                    name1,name2,part,nrJunks);
            fi;
        od: 
    od; 
od:

## Parallel version:
## At this point, check whether all files are ready. If not
## exit (another process will pick from there on!)
f := TimedCallSystem('find Cache/AllAll -type f | grep -v ".gz"')[2]:
if length(f) > 0 then
    print('** At least 1 process appears to be still computing the all-vs-all.');
    print('** The following file(s) is (are) not yet completed:');
    print(f);
    print('** If no other process is running, delete these files and restart.');
    quit;
fi:


##############################################################################
# Candidate Pairs

print('\n\n****\n\nReading the all-against-all files...\n');

ns := CreateArray(1..NG):
Lengths := CreateArray(1..NG):
for i to NG do
    if GS[genomes[i]]='unassigned' then
        lprint(genomes[i],'missing GenomeSummary information');  quit fi;
    t := GS[genomes[i],EntryLengths];
    ns[i] := length(t);
    Lengths[i] := t
od:
t1 := Counter('RefinedMatches structures read'):
t2 := Counter('Matches read'):
t3 := Counter('files read'):
t4 := Counter('Matches of genomes against themselves'):
t5 := Counter('Matches above parameters');
t6 := Counter('empty all-all'):
t7 := Counter('Number of matches discarded below MinSeqLen');

# Read the BestMatch from all x all files #

    BestMatch := CreateArray(1..NG,1..NG):
    for i to NG do for j from i to NG do
        BestMatch[i,j] := CreateArray(1..ns[i],[]);
        if j>i then BestMatch[j,i] := CreateArray(1..ns[j],[]) fi;
        if ns[i] < ns[j] or ns[i]=ns[j] and genomes[i] < genomes[j] then
            g1 := i;  g2 := j else g2 := i;  g1 := j fi;
        BestMatch1 := BestMatch[g1,g2];  BestMatch2 := BestMatch[g2,g1];
        t3+1;
        Exclude1 := Exclude2 := {}:
        db1 := DBs[g1]; db2 := DBs[g2]:
        # if there exist a 1-chunk archive, process it with higher priority
        fn1chunk := sprintf('Cache/AllAll/%s/%s.gz',genomes[g1],genomes[g2]);
        if FileExists(fn1chunk) then
            ReadProgram(fn1chunk);
            fnSepHash := sprintf('Cache/AllAll/%s/%s.sha2', genomes[g1], genomes[g2]);
            if FileExists(fnSepHash) then ReadProgram(fnSepHash) fi:
        else
            nrJunks := NumberOfJunks(genomes[g1],genomes[g2]);
            for part to nrJunks do 
                fn := sprintf('Cache/AllAll/%s/%s_%d-%d',genomes[g1],genomes[g2],
                    part, nrJunks);
                ReadProgram( fn );
            od:
        fi;
        # no Pairs should be cut for being below the Scoretol, as those
        # may serve to break a stable pair
        sij := sum(length(BestMatch[i,j,k]), k=1..length(BestMatch[i,j]));
        sji := sum(length(BestMatch[j,i,k]), k=1..length(BestMatch[j,i]));
        t5+max(sij,sji);
        if sij=0 or sji=0 then
            t6+1;
            # relax in case of mitochondion genome or synthetic evolution
            warning('empty all-all for '.genomes[g1].' '. genomes[g2] ) 
        fi;
        for k to length(BestMatch[i,j]) do
            if BestMatch[i,j,k] <> [] then
            BestMatch[i,j,k] := compress(BestMatch[i,j,k]) fi od;
        for k to length(BestMatch[j,i]) do
            if BestMatch[j,i,k] <> [] then
            BestMatch[j,i,k] := compress(BestMatch[j,i,k]) fi od;
        printf( '# %s vs %s done, (%d/%d)\n', genomes[g1],genomes[g2], 
            sij, sji );
    od od:



##############################################################################
# Verification of stable pairs and clique building or esprit 

cput_mid := time(); time_mid := UTCTime();
printlevel := 3:
NumberFormat := '%.8g':
params := [MinScore, LengthTol, StablePairTol, VerifiedPairTol, UseEsprit]:
ParamSet := [];

if UseEsprit then
    print('\n\n****\n\nRunning ESPRIT for the detection of split-genes\n');
    Esprit([MinProbContig, MinBestScore, DistConfLevel,
            true, MaxContigOverlap]):
    WriteEspritResults();
else
    # check whether orthologs have already been computed
    orthoCacheFile := 'Cache/ortholog_milestone.drw.gz':
    needComp := true;
    if FileExists(orthoCacheFile) then
        err := traperror(ReadProgram(orthoCacheFile));
        if err=lasterror then 
            CallSystem('rm -f '.orthoCacheFile); 
        else needComp := false;
        fi:
    fi:

    if needComp then 
        print('\n\n****\n\nIdentification of Stable-Pairs (Putative Orthologs)\n');
        Ort := OrthologousMatrix( op(params) ):
        StoreOrthologMilestone( orthoCacheFile );
    fi:

    if DoHierarchicalGroups=true then
        printlevel := 1:
        if SpeciesTree='estimate' then
            speciesTree := BuildSpeciesTree( Ort );
        elif SpeciesTree='lineage' then
            speciesTree := NULL:
        elif type(SpeciesTree,string) then
            speciesTree := ParseNewickTree(SpeciesTree,
                'defaultBranchLength'=1):
        fi:
        # call hierarchical group procedure
        HOG := traperror(HierarchicalGroups(ReachabilityCutoff,speciesTree));
    fi:
    # # Retrieve all IDs
    # # Create File MapSeqNum-ID:
    CallSystem('rm -rf Output; mkdir -p Output/PairwiseOrthologs');
    IDtable := CreateArray(1..NG);
    OpenWriting('Output/Map-SeqNum-ID.txt');
    print('\#Format: genome<tab>sequence number<tab>id');
    for i to NG do
        DB := DBs[i];
        tmp := CreateArray(1..ns[i]);
        for j to DB[TotEntries] do
            tmp[j] := SearchTag('ID',Entry(j));
            printf('%s\t%d\t%s\n',genomes[i],j,tmp[j]);
        od;
        IDtable[i] := tmp;
    od:
    OpenWriting(previous);


    ############################################################################
    # Store results
    Set('printgc'=false);
    print('\n\n****\n\nStoring results\n');

    if lasterror <> 'lasterror' then
        print('Abort because of error: '.lasterror);
        # quit;
    fi:

    OGtable := CreateArray(1..NG):
    for i to NG do OGtable[i] := CreateArray(1..ns[i]); od:
    for r to length(Ort) do
        for k to NG do
            t := Ort[r,k];
            if t <> 0 then 
                OGtable[k,t] := r;
            fi;
        od;
    od:

    # Store the pairwise orthologs
    for i to NG do for j from i+1 to NG do
        if ns[i] < ns[j] or ns[i]=ns[j] and genomes[i] < genomes[j] then
            g1 := i;  g2 := j else g2 := i;  g1 := j fi;
            OpenWriting('Output/PairwiseOrthologs/'.genomes[g1].'-'.genomes[g2]
                .'.txt');
        printf('\# Format: Protein 1<tab>Protein 2<tab>Protein ID1<tab>ProteinID2'
             .'<tab>Orthology type<tab>OMA group (if any)\n');
        printf('\# Every pair is listed only once, and in no particular order.\n');
        printf('\# The map between sequence number and ID are given\n');
        printf('\# in the file "Map-SeqNum-ID.map\n');

        for k to ns[g1] do
            vp := decompress(VPairs[g1,g2,k]);
            typ2 := If(length(vp)>1,'many','1');
            for l in vp do
                # if only 1 in target -> :1, else :many
                # l
                typ1 := If(length(decompress(VPairs[g2,g1,l]))>1,'many','1');
                printf('%d\t%d\t%s\t%s\t%s:%s\t%s\n',
                    k,l,
                    IDtable[g1,k],
                    IDtable[g2,l],
                    typ1, typ2,
                    If(OGtable[g1,k]=OGtable[g2,l] and OGtable[g1,k] <> 0, 
                        string(OGtable[g1,k]),
                        '')
                );
            od;
        od:
        OpenWriting(previous);
    od;od:
    # store the pairwise orthologs in orthoxml format
    WriteOrthoXML( VPairs, 'Output/OrthologousPairs.orthoxml');

    # Store the groups of orthologs
    WriteMatrix(Ort,'Output/OrthologousMatrix.txt');
    WriteGroups(Ort,'Output/OrthologousGroups.txt');
    # store orthologous groups in orthoxml format
    WriteOrthoXML( Ort, 'Output/OrthologousGroups.orthoxml',
        StableIdsForGroups=true);
    
    # developpment code
    if type(MergeOMAGroups, procedure) then
        mergedOMAGroups := MergeOMAGroups(Ort, VPairs);
        WriteOrthoXML( mergedOMAGroups, 'Output/MergedOMAGroups.orthoxml',
            StableIdsForGroups=true);
        WriteMatrix( mergedOMAGroups, 'Output/MergedOMAMatrix.txt');
        WriteGroups( mergedOMAGroups, 'Output/MergedOMAGroups.txt');
    fi:

    # store all orthologous groups in fasta format
    WriteFastaGroups('Output/OrthologousGroupsFasta', Ort):

    # store hierarchical groups if computed
    if DoHierarchicalGroups=true then
        WriteOrthoXML( HOG, 'Output/HierarchicalGroups.orthoxml',
            StableIdsForGroups=true);
        WriteFastaGroups('Output/HOGFasta', HOG);
        if SpeciesTree='estimate' then
            OpenWriting('Output/EstimatedSpeciesTree.nwk');
            prints( Tree_Newick(speciesTree) .';' );
            OpenWriting(previous):
        fi:
    fi:

fi:

print('\n\n***\n\nDone!!\n\n');
